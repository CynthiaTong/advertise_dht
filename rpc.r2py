dy_import_module_symbols("lookup.r2py")
dy_import_module_symbols("routing.r2py")
dy_import_module_symbols("storage.r2py")
dy_import_module_symbols("util.r2py")

LOOKUP_CAPACITY = 14 
DHT_LOOKUP_EXPIRE_TIME = 62 * 60
DHT_MAX_LOOKUPS = 1024 # why?
DHT_EVENT_LOOKUPS_DONE = 3 
BUF_SIZE = 512 #BYTES 
LARGE_BUF_SIZE = 2048 
# Question: my_v ??

class RPC:
	def __init__(self, string_id, routing_table, storage):
		self.id = string_id 
		self.router = routing_table
		self.storage = storage

	"""
		QUERY METHODS 
	"""
	def ping(self, ip, port, tid, tid_len):
		buf = "d1:ad2:id20:%se1:q4:ping1:t%d:%s1:y1:qe" % (self.id, tid_len, tid)
		log (buf, "\n")
		if len(buf) <= BUF_SIZE:
			return buf 
			# return dht_send(buf, buf_len, 0, socket_address, address_len)

	def find_node(self, tid, tid_len, target_id):
		buf = ("d1:ad2:id20:%s6:target20:%se1:q9:find_node1:t%d:%s1:y1:qe" % 
					(self.id, target_id, tid_len, tid))
		if len(buf) <= BUF_SIZE:
			log (buf, "\n")
			return buf 

	# no ipv6 support here 
	def get_peers(self, ip, port, tid, tid_len, info_hash):	
		buf = ("d1:ad2:id20:%s9:info_hash20:%se1:q9:get_peers1:t%d:%s1:y1:qe" % 
					(self.id, info_hash, tid_len, tid))
		if len(buf) <= BUF_SIZE:
			log (buf, "\n")
			return buf 

	def announce_peer(self, ip, port, tid, tid_len, info_hash, token, token_len):
		buf = ("d1:ad2:id20:%s9:info_hash20:%s4:porti%de5:token%d:%se1:q13:announce_peer1:t%d:%s1:y1:qe" % 
					(self.id, info_hash, port, token_len, token, tid_len, tid))
		if len(buf) <= BUF_SIZE:
			log (buf, "\n")
			return buf # send 

	"""
		REPLY METHODS 
	"""
	def pong(self, ip, port, tid, tid_len):
		buf = "d1:rd2:id20:%se1:t%d:%s1:y1:re" % (self.id, tid_len, tid)
		if len(buf) <= BUF_SIZE:
			log (buf, "\n")
			return buf 

	def send_closest_nodes(self, ip, port, tid, tid_len, target_id_str, token, token_len):
		target_id_long = string_to_long(target_id_str, 20)
		nodes_list = self.router.get_closest_good_nodes(target_id_long)
		nodes_str = ''.join(nodes_list)
		nodes_len = len(nodes_list) * 6 
		# log (nodes_list, "\t", nodes_str,"\n")
		# log (len(nodes_str), "\t", nodes_len, "\n")
		# retrieve peers with target_id_str from storage  
		peers_list = self.storage.retrieve(target_id_str)
		# if peers_list:
		# 	for p in peers_list:
		# 		log (p, "\n")
		# 	log ("---------\n")
		return self.send_nodes_peers(ip, port, tid, tid_len, nodes_str, nodes_len, peers_list, token, token_len)

	def send_nodes_peers(self, ip, port, tid, tid_len, nodes_str, nodes_len, peers_list, token, token_len):
		buf = "d1:rd2:id20:%s" % self.id 
		# add nodes string  
		buf += "5:nodes%d:%s" % (nodes_len, nodes_str)

		if token_len > 0:
			buf += "5:token%d:%s" % (token_len, token)

		if peers_list and len(peers_list) > 0:
			buf += "6:valuesl"
			for p in peers_list:
				# !! port needs to be big endian 
				buf += "%d:%s%s" % (6, ip_as_bytes(p.ip), str(htons(p.port)))
				# log (list(ip_as_bytes(p.ip)+str(htons(p.port))), "\n")
			buf += "e"
		buf += "e1:t%d:%s1:y1:re" % (tid_len, tid)
		if len(buf) <= LARGE_BUF_SIZE:
			log (buf, "\n")
			return buf 

	def peer_announced(self, ip, port, tid, tid_len):
		buf = "d1:rd2:id20:%se1:t%d:%s1:y1:re" % (self.id, tid_len, tid)
		if len(buf) <= BUF_SIZE:
			log (buf, "\n")
			return buf 

	def send_error(self, ip, port, tid, tid_len, error_code, error_msg):
		msg_len = len(error_msg)
		buf = "d1:eli%de%d:%s" % (error_code, msg_len, error_msg)
		buf += "e1:t%d:%s1:y1:ee" % (tid_len, tid)

		if len(buf) <= BUF_SIZE:
			log (buf, "\n")
			return buf 


	def length_check(self, index, length, buf_len):
		if index + length > buf_len:
			log ("Failed length check.\n")
			return False 
		return True 

	def parse_message(self, buf, tid_len=4, token_len=16, nodes_len=8, values_len=256): 
		# change string.find to a more efficient method??
		buf_len = len(buf)
		tid = sender_id = info_hash = target = token = ""
		nodes = list()
		values = list()
		port = 0 

		# parse tid if it exists and adheres to our rule 
		p = buf.find("1:t")
		if p > -1:
			l = int(buf[p+3])
			if 0 < l <= tid_len and buf[p+4] == ":":
				k = p+5
				while not (buf[k] == "1" and buf[k+1] == ":"):
					tid += buf[k]
					k += 1 
				tid_len = len(tid)
				log ("tid(tid_len): ", tid, " (", tid_len, ") \n")
			else:
				tid_len = 0 
		else:
			tid_len = 0 

		p = buf.find("2:id20:")
		if p > -1:
			if self.length_check(p+7, 20, buf_len):
				sender_id = buf[p+7:p+7+20]
				log ("sender id: ", sender_id, "\n")
			else:
				sender_id = 0 

		p = buf.find("9:info_hash20:")
		if p > -1:
			if self.length_check(p+14, 20, buf_len):
				info_hash = buf[p+14:p+14+20]
				log ("infohash: ", info_hash, "\n")
			else:
				info_hash = 0 

		p = buf.find("porti")
		if p > -1:
			n_str = ""
			q = p+5
			while q < buf_len and buf[q].isdigit():
				n_str += buf[q]
				q += 1 
			n = int(n_str)
			if buf[q] and buf[q] == 'e' and 0 < n < 0x10000:
				log ("port: ", n, "\n")
				port = n

		p = buf.find("6:target20:")
		if p > -1:
			if self.length_check(p+11, 20, buf_len):
				target = buf[p+11:p+11+20]
				log("target: ", target, "\n")
			else:
				target = 0 

		p = buf.find("5:token")
		if p > -1:
			l_str = ""
			q = p+7 
			while q < buf_len and buf[q].isdigit():
				l_str += buf[q]
				q += 1 
			l = int(l_str)
			if (0 < l <= token_len and buf[q] == ":" and 
					self.length_check(p+7, token_len, buf_len)):
				token = buf[q+1:q+1+l]
				token_len = l 
				log ("token(token_len): ", token, " (", token_len, ") \n")
			else: 
				token_len = 0 
		else:
			token_len = 0

		p = buf.find("5:nodes")
		if p > -1:
			l_str = ""
			q = p+7 
			while q < buf_len and buf[q].isdigit():
				l_str += buf[q]
				q += 1 
			l = int(l_str)
			if 0 < l <= nodes_len and buf[q] == ":":
				k = q+1
				while not (buf[k] == "5" and buf[k+1] == ":"):
					nodes.append(ord(buf[k]))
					k += 1 
				nodes_len = len(nodes)
				log ("nodes(nodes_len): ", nodes, " (", nodes_len, ") \n")
			else:
				nodes_len = 0 
		else:
			nodes_len = 0  

		# parse values 
		p = buf.find("6:valuesl")
		if p > -1:
			q = p+9 
			while True: 
				l_str = ""
				l = 0 
				while q < buf_len and buf[q].isdigit():
					l_str += buf[q]
					q += 1 
				if l_str:
					l = int(l_str)
				if q < buf_len and buf[q] == ":":
					if l == 6:
						k = q+1
						while not ((buf[k] == "6" and buf[k+1] == ":") or buf[k] == "e"):
							values.append(ord(buf[k]))
							k += 1 
						q = k
					else:
						log ("Received weird value -- %d bytes.\n" % l )
				else:
					break 
			if q < buf_len and buf[q] == "e":
				values_len = len(values)
				log ("values(len): ", values, " (", values_len, ") \n")
			else:
				log ("Unexpected end for values.\n")
		else:
			values_len = 0 


		if buf.find("1:y1:r") > -1:
			log ("REPLY\n")
			return "REPLY" 
		if buf.find("1:y1:e") > -1:
			log ("ERROR\n")
			return "ERROR"
		if buf.find("1:y1:q") == -1:
			log ("-1\n")
			return -1  
		if buf.find("1:q4:ping") > -1:
			log ("PING\n")
			return "PING"
		if buf.find("1:q9:find_node") > -1:
			log ("FIND_NODE\n")
			return "FIND_NODE"
		if buf.find("1:q9:get_peers") > -1:
			log ("GET_PEERS\n")
			return "GET_PEERS"
		if buf.find("1:q13:announce_peer") > -1:
			log ("ANNOUNCE_PEER\n")
			return "ANNOUNCE_PEER"
		
		log ("-1\n")
		return -1 
