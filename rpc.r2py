util = dy_import_module("util.r2py")

LOOKUP_CAPACITY = 14 
DHT_LOOKUP_EXPIRE_TIME = 62 * 60
DHT_MAX_LOOKUPS = 1024 
DHT_EVENT_LOOKUPS_DONE = 3 
BUF_SIZE = 512 #BYTES 
LARGE_BUF_SIZE = 2048 


def send(buf, target_ip, target_port):
  # for debugging 
  # target_ip = getmyip()
  # target_port = 6881 
  log ("Sending msg to %s : %d\n" % (target_ip, target_port))

  ip = getmyip()
  port = 63101  # range: 63100, 63201

  sendmessage(target_ip, target_port, buf, ip, port)


def add_version(version):
  if version:
    return "1:v4:" + version + "1:y1:qe"
  else:
    return "1:y1:qe"

"""
  QUERY METHODS 
"""
def ping(self_id, ip, port, tid, tid_len, v=None):
  buf = "d1:ad2:id20:%se1:q4:ping1:t%d:%s" % (self_id, tid_len, tid)
  buf += add_version(v)

  if len(buf) <= BUF_SIZE:
    # log (buf, "\n")
    return send(buf, ip, port)

def find_node(self_id, ip, port, tid, tid_len, target_id, v=None):
  buf = ("d1:ad2:id20:%s6:target20:%se1:q9:find_node1:t%d:%s" % 
        (self_id, target_id, tid_len, tid))
  buf += add_version(v)
  if len(buf) <= BUF_SIZE:
    # log (buf, "\n")
    return send(buf, ip, port)

# no ipv6 support here 
def get_peers(self_id, ip, port, tid, tid_len, info_hash, v=None): 
  buf = ("d1:ad2:id20:%s9:info_hash20:%se1:q9:get_peers1:t%d:%s" % 
        (self_id, info_hash, tid_len, tid))
  buf += add_version(v)
  if len(buf) <= BUF_SIZE:
    # log (buf, "\n")
    return send(buf, ip, port)

def announce_peer(self_id, ip, port, tid, tid_len, info_hash, lookup_port, token, token_len, v=None):
  buf = ("d1:ad2:id20:%s9:info_hash20:%s4:porti%de5:token%d:%se1:q13:announce_peer1:t%d:%s" % 
        (self_id, info_hash, lookup_port, token_len, token, tid_len, tid))
  buf += add_version(v)
  if len(buf) <= BUF_SIZE:
    # log (buf, "\n")
    return send(buf, ip, port)

"""
  REPLY METHODS 
"""
def pong(self_id, ip, port, tid, tid_len, v=None):
  buf = "d1:rd2:id20:%se1:t%d:%s" % (self_id, tid_len, tid)
  buf += add_version(v)
  if len(buf) <= BUF_SIZE:
    # log (buf, "\n")
    return send(buf, ip, port)

def send_closest_nodes(router, self_id, ip, port, tid, tid_len, target_id_str, 
                        token=None, token_len=0, peers_list=None, v=None):
  target_id_long = util.string_to_long(target_id_str)
  nodes_list = router.get_closest_good_nodes(target_id_long)
  nodes_str = ''.join(nodes_list)
  nodes_len = len(nodes_list) * 26 

  return send_nodes_peers(self_id, ip, port, tid, tid_len, nodes_str, nodes_len, peers_list, token, token_len, v)

def send_nodes_peers(self_id, ip, port, tid, tid_len, nodes_str, nodes_len, peers_list, token, token_len, v):
  buf = "d1:rd2:id20:%s" % self_id 
  # add nodes string if no peers_list is provided 
  # either it's a find_node, or no peer values found for get_peers)
  if not peers_list:
    buf += "5:nodes%d:%s" % (nodes_len, nodes_str)

  if token_len > 0:
    buf += "5:token%d:%s" % (token_len, token)

  if peers_list and len(peers_list) > 0:
    buf += "6:valuesl"
    for p in peers_list:
      # !! port needs to be big endian 
      buf += "%d:%s%s" % (6, util.ip_as_bytes(p.ip), str(util.htons(p.port)))
      # log (list(ip_as_bytes(p.ip)+str(htons(p.port))), "\n")
    buf += "e"
  buf += "e1:t%d:%s" % (tid_len, tid)
  buf += add_version(v)
  if len(buf) <= LARGE_BUF_SIZE:
    # log (buf, "\n")
    return send(buf, ip, port)

def peer_announced(self_id, ip, port, tid, tid_len, v=None):
  buf = "d1:rd2:id20:%se1:t%d:%s" % (self_id, tid_len, tid)
  buf += add_version(v)
  if len(buf) <= BUF_SIZE:
    log (buf, "\n")
    return send(buf, ip, port)

def send_error(ip, port, tid, tid_len, error_code, error_msg, v=None):
  msg_len = len(error_msg)
  buf = "d1:eli%de%d:%s" % (error_code, msg_len, error_msg)
  buf += "e1:t%d:%s" % (tid_len, tid)
  buf += add_version(v) + "e"
  if len(buf) <= BUF_SIZE:
    # log (buf, "\n")
    return send(buf, ip, port)

"""
  PUT 
"""

def put(self_id, value, ip, port, token, opts=None):
  # for key, val in opts.items():
  #   log (key, " ", val, "\n")
  tid = util.make_tid("pt", util.make_lid())
  msg = {
    'a': {
      'id': self_id,
      'token': token,
      'v': value 
    },
    't': tid, 
    'y': 'q',
    'q': 'put'
  }

  key = None 
  if opts:
    msg['a']['k'] = opts['k']
    msg['a']['seq'] = opts['seq']

    if opts.has_key('salt'):
      key = sha.sha_hash(opts['k'] + opts['salt'])
      msg['a']['salt'] = opts['salt']
    else:
      key = sha.sha_hash(opts['k'])

    if opts.has_key('cas'):
      msg['a']['cas'] = opts['cas']
  else:
    key = sha.sha_hash(value)

  msg = util.encoder(msg)
  log (msg, "\n")
  send(msg, ip, port)

  # return key 
  return msg 

def send_put(self_id, ip, port, tid):
  msg = util.encoder({"r":{"id": self_id}, "t": tid, "y": "r"})
  send(msg, ip, port)

