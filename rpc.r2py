dy_import_module_symbols("lookup.r2py")
dy_import_module_symbols("routing.r2py")
dy_import_module_symbols("storage.r2py")
dy_import_module_symbols("util.r2py")

LOOKUP_CAPACITY = 14 
DHT_LOOKUP_EXPIRE_TIME = 62 * 60
DHT_MAX_LOOKUPS = 1024 # why?
DHT_EVENT_LOOKUPS_DONE = 3 
BUF_SIZE = 512 
LARGE_BUF_SIZE = 2048 
# Question: my_v ??


class RPC:
	def __init__(self, string_id, routing_table, storage):
		self.id = string_id 
		self.router = routing_table
		self.storage = storage

	"""
		QUERY METHODS 
	"""
	def ping(self, ip, port, tid, tid_len):
		buf = "d1:ad2:id20:%se1:q4:ping1:t%d:%s1:y1:qe" % (self.id, tid_len, tid)
		# log (buf, "\n")
		if len(buf) <= BUF_SIZE:
			return buf 
			# return dht_send(buf, buf_len, 0, socket_address, address_len)

	def find_node(self, tid, tid_len, target_id):
		buf = ("d1:ad2:id20:%s6:target20:%se1:q9:find_node1:t%d:%s1:y1:qe" % 
					(self.id, target_id, tid_len, tid))
		if len(buf) <= BUF_SIZE:
			# log (buf, "\n")
			return buf 

	# no ipv6 support here 
	def get_peers(self, ip, port, tid, tid_len, info_hash):	
		buf = ("d1:ad2:id20:%s9:info_hash20:%se1:q9:get_peers1:t%d:%s1:y1:qe" % 
					(self.id, info_hash, tid_len, tid))
		if len(buf) <= BUF_SIZE:
			log (buf, "\n")
			return buf 

	def announce_peer(self, ip, port, tid, tid_len, info_hash, token, token_len):
		buf = ("d1:ad2:id20:%s9:info_hash20:%s4:porti%de5:token%d:%se1:q13:announce_peer1:t%d:%s1:y1:qe" % 
					(self.id, info_hash, port, token_len, token, tid_len, tid))
		if len(buf) <= BUF_SIZE:
			# log (buf, "\n")
			return buf # send 

	"""
		REPLY METHODS 
	"""
	def pong(self, ip, port, tid, tid_len):
		buf = "d1:rd2:id20:%se1:t%d:%s1:y1:re" % (self.id, tid_len, tid)
		if len(buf) <= BUF_SIZE:
			return buf 


	def send_closest_nodes(self, ip, port, tid, tid_len, target_id_str, token, token_len):
		target_id_long = string_to_long(target_id_str, 20)
		nodes_list = self.router.get_closest_good_nodes(target_id_long)
		nodes_str = ''.join(nodes_list)
		nodes_len = len(nodes_list) * 6 
		log (nodes_list, "\t", nodes_str,"\n")
		log (len(nodes_str), "\t", nodes_len, "\n")
		# retrieve peers with target_id_str from storage  
		peers_list = self.storage.retrieve(target_id_str)
		self.send_nodes_peers(ip, port, tid, tid_len, nodes_str, nodes_len, peers_list, token, token_len)

	def send_nodes_peers(self, ip, port, tid, tid_len, nodes_str, nodes_len, peers_list, token, token_len):
		buf = "d1:rd2:id20:%s" % self.id 
		# add nodes string  
		buf += "5:nodes%d:%s" % (nodes_len, nodes_str)
		if token_len > 0:
			buf += "5:token%d:%s" % (token_len, token)

		if peers_list and len(peers_list) > 0:
			buf += "6:valuesl"
			for p in peers_list:
				# !! port needs to be big endian 
				buf += "%d:%s" % (6, p.ip + p.port)
			buf += "e"
		buf += "e1:t%d:%s1:y1:re" % (tid_len, tid)
		if len(buf) <= LARGE_BUF_SIZE:
			log (buf, "\n")
			return buf 
