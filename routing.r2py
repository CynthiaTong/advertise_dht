dy_import_module_symbols("bucket.r2py")
dy_import_module_symbols("lookup.r2py")
dy_import_module_symbols("rpc.r2py")
dy_import_module_symbols("util.r2py")
dy_import_module_symbols("random.r2py")

class RoutingTable:

	def __init__(self, long_id, ksize):
		self.id = long_id
		self.ksize = ksize 
		self.expire_buckets_time = 0  
		self.initial_bucket()

	def initial_bucket(self):
		self.buckets = [Bucket(0, 2**160, self.ksize)]

	def split_bucket(self, index, bucket):
		self.ping_replacement(bucket)
		bucket_1, bucket_2 = bucket.split()
		self.buckets[index] = bucket_1 
		self.buckets.insert(index+1, bucket_2)

	"""
		Instead, have a purge bad nodes function 
	"""
	# def remove_contact(self, node):
	# 	index = self.find_bucket(node)[0]
	# 	self.buckets[index].remove_node(node)

	# purge all bad nodes with pinged value >= 4 
	def purge_bad_nodes(self):
		for b in self.buckets:
			for n in b.nodes:
				if n.pinged >= 4:
					b.remove_node(n)
					# ping a replacement node 
					self.ping_replacement(b)
					self.expire_buckets_time = get_time() + 120 + random_int_below(240)

	"""
		not necessarily "new" contact 
		message_type: 
			0 for reply 
			1 for query 
	"""
	def add_contact(self, node, message_type):

		# never add if the node ID is identical to our own ID  
		if node.long_id == self.id:
			return False 

		index, bucket = self.find_bucket(node)

		# Remove a known bad node 
		for n in bucket.nodes:
			if not n.good_node():
				bucket.remove_node(n)
				log ("Node ", n.long_id, " gets removed. ", 
							n.pinged, "  ", n.last_queried, "  ", n.last_replied ,"\n")
				break 

		if bucket.add_node(node, message_type):
			return True 
	
		# New node and bucket full of good nodes 

		# if table's owner node is in the bucket, split 
		if bucket.in_range(self.id):
			self.split_bucket(index, bucket)
			# try adding again 
			self.add_contact(node, message_type)
		else: 
			for n in bucket.nodes:
				# find a dubious node to Ping 
				if n.pinged >= 3 and n.last_pinged < get_time() - 15:
					log ("Node ", n.long_id, " gets pinged.\n")
					tid = make_tid("pn", 0)
					# Ping that node 
					RPC.ping(n.ip, n.port, tid, 4)
					n.pinged += 1 
					n.last_pinged = get_time()
					break 
			# add to bucket's replacement list if there's space left 
			if len(bucket.replacements) < self.ksize:
				bucket.add_replacement(node, message_type)

	# get buckets that haven't been queried in the last hour (to refresh)
	def get_unvisited_buckets(self):
		return [b for b in self.buckets if get_time() - b.last_visited >= 3600]

	def find_node(self, target_id):
		i, bucket = self.find_bucket(target_id)
		for n in bucket.get_nodes():
			if n.id == target_id:
				return n 
		return None 

	# find proper bucket for contact (id in bucket's range)
	# return index and the bucket itself 
	def find_bucket(self, *args):
		arg = args[0]
		for b in self.buckets:
			if b.in_range(arg):
				return self.buckets.index(b), b

		raise ValueError("Node ID not in range: 0 - 2**160")

	# Get the strictly closest good nodes to a given target ID 
	def get_closest_good_nodes(self, target_id, tid, search_size=None):
		search_size = search_size or self.ksize
		lookup = Lookup(target_id, tid, search_size)
		# linear scan through the routing table, and add to lookup list 
		for b in self.buckets:
			for n in b.get_nodes():
				if n.good_node():
					lookup.insert(n, 0, None)
		# Note: closest in this list at head 
		return lookup

	# Might just need to scan the whole routing table to find STRICTLY closest 
	# (above get_closest_nodes function)
	def get_lookup_nodes(self, lookup, target_id):
		# find the bucket and add its nodes 
		current_index, current_bucket = self.find_bucket(target_id)
		self.add_to_lookup(current_bucket, lookup)

		left_index = current_index - 1  
		right_index = current_index + 1 
		go_left = True 

		# while lookup list is not full and there are still buckets we haven't been, 
		# add from neighboring buckets in the order: left, right, left, etc 
		while not lookup.is_full() and (left_index > 0 or right_index < len(self.buckets)):
			if left_index >= 0 and go_left:
				previous_bucket = self.buckets[left_index]
				self.add_to_lookup(previous_bucket, lookup)
				left_index -= 1 
				go_left = False 

			if current_index < len(self.buckets):
				next_bucket = self.buckets[right_index]
				self.add_to_lookup(next_bucket, lookup)
				right_index += 1 
				go_left = True 

		# Note: closest in this list at head 
		return lookup

	def add_to_lookup(self, bucket, lookup):
		nodes = bucket.get_nodes()
		for n in nodes:
			lookup.insert(n, 0, None) # node, replied, token

	def pinged(self, node, bucket=None):
		node.pinged += 1 
		node.last_pinged = get_time()
		if node.pinged >= 3:
			if bucket:
				self.ping_replacement(bucket)
			else:
				self.ping_replacement(self.find_bucket(node)[1])

	def ping_replacement(self, bucket):
		tid = make_tid("pn", 0)
		if len(bucket.replacements) > 0:
			top = bucket.replacements[-1]
			log ("Sending ping to replacement node.\n")
			RPC.ping(top.ip, top.port, tid, 4)
