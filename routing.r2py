dy_import_module_symbols("bucket.r2py")
dy_import_module_symbols("lookup.r2py")
dy_import_module_symbols("util.r2py")
dy_import_module_symbols("random.r2py")

class RoutingTable:

	def __init__(self, long_id, ksize):
		self.id = long_id
		self.ksize = ksize 
		self.expire_buckets_time = 0  
		self.initial_bucket()

	def initial_bucket(self):
		self.buckets = [Bucket(0, 2**160, self.ksize)]

	def split_bucket(self, index):
		bucket_1, bucket_2 = self.buckets[index].split()
		self.buckets[index] = bucket_1 
		self.buckets.insert(index+1, bucket_2)

	"""
		Instead, have a purge bad nodes function 
	"""
	# def remove_contact(self, node):
	# 	index = self.find_bucket(node)[0]
	# 	self.buckets[index].remove_node(node)

	# purge all bad nodes with pinged value >= 4 
	def purge_bad_nodes(self):
		changed = False 
		for b in self.buckets:
			for n in b.nodes:
				if n.pinged >= 4:
					b.remove_node(n)
					changed = True

		if changed:
			self.expire_buckets_time = get_time() + 120 + random_int_below(240)


	"""
		not necessarily "new" contact 
		message_type: 
			0 for reply 
			1 for query 
	"""
	def add_contact(self, node, message_type):

		# never add if the node ID is identical to our own ID  
		if node.long_id == self.id:
			return False 

		index, bucket = self.find_bucket(node)

		if bucket.add_node(node, message_type):
			return True 
	
		# New node and bucket full 

		# Remove a known bad node 
		for n in bucket.nodes:
			if not n.good_node():
				removed = bucket.remove_node(n)
				if removed:
					log ("Node ", n.long_id, " gets removed. ", 
							n.pinged, "  ", n.last_queried, "  ", n.last_replied ,"\n")
				break 

		# if table's owner node is in the bucket, split 
		if bucket.in_range(self.id):
			self.split_bucket(index)
			# try adding again 
			self.add_contact(node, message_type)
		else: 
			# Ping least recent seen node 
			log ("Node ", bucket.get_oldest().long_id, " gets pinged.\n")
			bucket.get_oldest().pinged += 1  
			# ADD PING!! 

			# add to bucket's replacement list 
			bucket.add_replacement(node, message_type)

	# get buckets that haven't been queried in the last hour (to refresh)
	def get_unvisited_buckets(self):
		return [b for b in self.buckets if get_time() - b.last_visited >= 3600]

	# find proper bucket for contact (id in bucket's range)
	# return index and the bucket itself 
	def find_bucket(self, node):
		for b in self.buckets:
			if b.in_range(node):
				return self.buckets.index(b), b

		raise ValueError("Node ID not in range: 0 - 2**160")

	# Get the strictly closest good nodes to a given target ID 
	def get_closest_good_nodes(self, target_id, tid, search_size=None):
		search_size = search_size or self.ksize
		lookup = Lookup(target_id, tid, search_size)
		# linear scan through the routing table, and add to lookup list 
		for b in self.buckets:
			for n in b.get_nodes():
				if n.good_node():
					lookup.insert(n)
		# Note: closest in this list at head 
		return lookup

	# Might just need to scan the whole routing table to find STRICTLY closest 
	# (above get_closest_nodes function)
	def get_lookup_nodes(self, lookup, target_id):
		# find the bucket and add its nodes 
		current_index, current_bucket = self.find_bucket(Node(target_id))
		self.add_to_lookup(current_bucket, lookup)

		left_index = current_index - 1  
		right_index = current_index + 1 
		go_left = True 

		# while lookup list is not full and there are still buckets we haven't been, 
		# add from neighboring buckets in the order: left, right, left, etc 
		while not lookup.is_full() and (left_index > 0 or right_index < len(self.buckets)):
			if left_index >= 0 and go_left:
				previous_bucket = self.buckets[left_index]
				self.add_to_lookup(previous_bucket, lookup)
				left_index -= 1 
				go_left = False 

			if current_index < len(self.buckets):
				next_bucket = self.buckets[right_index]
				self.add_to_lookup(next_bucket, lookup)
				right_index += 1 
				go_left = True 

		# Note: closest in this list at head 
		return lookup

	def add_to_lookup(self, bucket, lookup):
		nodes = bucket.get_nodes()
		for n in nodes:
			lookup.insert(n)
