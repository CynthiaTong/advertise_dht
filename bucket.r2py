random = dy_import_module("random.r2py")
node = dy_import_module("node.r2py")

class Bucket:
  """
    <Purpose>
    Buckets are used to group up nodes in the DHT's Routing Table. 
    <Side Effects>
    Used by the RoutingTable module. 
    <Example Use>
    # create a bucket 
    bucket = Bucket(0, 2**4, 3)
    # add a node to the bucket 
    bucket.add_node(node_obj, 0)
    # remove a node 
    bucket.remove_node(node_obj)
    # split the bucket 
    bucket.split()
  
  """   

  def __init__(self, min, max, ksize):
    self.min = min
    self.max = max
    self.ksize = ksize
    self.nodes = list()
    self.replacements = list() #should be a stack (set)
    self.last_changed = 0

  """
    The in_range function takes in one parameter that can be either a Node object 
    or an integer/long number. 
    It returns true if the object fits within this bucket's range, false otherwise. 
    Note: min is inclusive, max is exclusive.

  """
  def in_range(self, *args):
    arg = args[0]
    if isinstance(arg, node.Node):
      return self.min <= arg.long_id < self.max
    elif isinstance(arg, (int, long)):
      return self.min <= arg < self.max 

  """
    Add a node to the bucket. 
    If node already exists, update its time info and move it to tail, then return True. 
    Otherwise node is new, append it, update its time info and return True. 
    If bucket is full, return False 
    message_type argument is defaulted to 2 (general type)
  """
  def add_node(self, node, message_type=2):
    duplicates = None 
    for n in self.nodes:
      if n.ip == node.ip and n.port == node.port:
        duplicates = n  
        break   
    if duplicates:
      # move existing node to tail
      self.nodes.remove(duplicates)
      self.nodes.append(duplicates)
      node = duplicates
    elif len(self.nodes) < self.ksize:
      self.nodes.append(node)
    # New node and bucket full 
    else:
      return False
    # node added, update bucket last_changed 
    self.last_changed = getruntime()
    self.update_time_info(node, message_type)
    # log ("NEW NODE ", node.long_id, " ", node.pinged, " ", node.last_queried, " ", node.last_replied ,"\n")
    return True

  """
    Add a node to the bucket's replacement list (stack). 
    If node already exists, update its time info and move it to tail (top). 
    Otherwise node is new, append it and update its time info. 
    
  """
  def add_replacement(self, node, message_type):
    # if the node exists in replacements, move it to tail (top)
    duplicates = None 
    for n in self.replacements:
      if n.ip == node.ip and n.port == node.port:
        duplicates = n  
        break   
    if duplicates:
      self.replacements.remove(duplicates)
      node = duplicates
    self.replacements.append(node)
    self.update_time_info(node, message_type)
  
  """
    Update node's time info based on the message type: 
    If request (msg_type == 1), update node's last_queried field; 
    If response (msg_type == 0), update node's replied fields and bucket's last_changed. 

  """
  def update_time_info(self, node, msg_type):
    if msg_type:
      node.last_queried = getruntime()
    else:
      node.pinged = 0 
      node.replied = 1 
      node.last_replied = getruntime()
      # node replied, update bucket last_changed  
      self.last_changed = getruntime()

  """
    Remove a node from bucket. If node does not exist, return False. 
    Otherwise, remove the node, and try adding a good node from the replacement stack, return True. 
    
  """
  def remove_node(self, node):
    existing_node = None 
    for n in self.nodes:
      if n.ip == node.ip and n.port == node.port:
        existing_node = n  
        break   

    if not existing_node:
      return False

    self.nodes.remove(existing_node)
    # try adding a good node from the top of the replacement stack 
    while len(self.replacements) > 0:
      replacement_node = self.replacements.pop()
      if replacement_node.good_node():
        self.nodes.append(replacement_node)
        # node replaced, update bucket last_changed 
        self.last_changed = getruntime()
        break 
    return True

  """
    Split the bucket into two buckets with halfs of the original range. 
    Populate the new buckets with existing nodes, and return the two buckets. 

  """
  def split(self):
    if self.min >= self.max:
      log("Cannot split bucket: min >= max")
      return

    mid = (self.min + self.max) / 2
    bucket_1 = Bucket(self.min, mid, self.ksize)
    bucket_2 = Bucket(mid, self.max, self.ksize)

    for n in self.nodes:
      new_bucket = None
      if n.long_id <= mid:
        new_bucket = bucket_1
      else:
        new_bucket = bucket_2
      new_bucket.add_node(n)

    return bucket_1, bucket_2

  """
    Getter for all nodes in this bucket 
  """
  def get_nodes(self):
    return self.nodes

  """
    Return the number of nodes in this bucket 
  """
  def node_count(self):
    return len(self.nodes)

  """
    Return oldest node in this bucket (at index 0 of node list)
  """
  def get_oldest(self):
    return self.nodes[0]

  """
    Return a random integer value within the bucket's range 
  """
  def random_id(self):
    return random.random_randint(self.min, self.max)

  """
    Return a random node within the bucket 
  """
  def random_node(self):
    n = random.random_int_below(len(self.nodes))
    return self.nodes[n]

  """
    String representation of the bucket 
  """
  def __str__(self):
    output = "Bucket last changed: %.2f\n" % self.last_changed
    for n in self.nodes:
      output += str(n) + "\n"
    return output
