dy_import_module_symbols("node.r2py")
dy_import_module_symbols("random.r2py")
dy_import_module_symbols("util.r2py")

class Bucket:

	def __init__(self, min, max, ksize):
		self.min = min
		self.max = max
		self.ksize = ksize
		self.nodes = list()
		self.replacements = list() #should be a stack (set)
		self.update_last_visited()

	def update_last_visited(self):
		self.last_visited = get_time()

	# min: inclusive, max: exclusive 
	def in_range(self, *args):
		arg = args[0]
		if isinstance(arg, Node):
			return self.min <= arg.long_id < self.max
		elif isinstance(arg, (int, long)):
			return self.min <= arg <= self.max 

	def add_node(self, node, message_type=None):
		if node in self.nodes:
			# move existing node to tail
			self.nodes.remove(node)
			self.nodes.append(node)
		elif len(self.nodes) < self.ksize:
			self.nodes.append(node)
		# New node and bucket full 
		else:
			return False

		self.update_time_info(node, message_type)
		# log ("NEW NODE ", node.long_id, "  ", node.pinged, "  ", node.last_queried, "  ", node.last_replied ,"\n")
		return True

	def add_replacement(self, node, message_type):
		# if the node exists in replacements, move it to tail (top)
		if node in self.replacements:
			self.replacements.remove(node)
		self.replacements.append(node)
		self.update_time_info(node, message_type)
	
	# update node's time info based on the message type (req or res)
	def update_time_info(self, node, message_type):
		if message_type:
			node.last_queried = get_time()
		else:
			node.pinged = 0 
			node.replied = True 
			node.last_replied = get_time()

	def remove_node(self, node):

		if node not in self.nodes:
			return False

		self.nodes.remove(node)
		# try adding one node from the top of the replacement stack
		if len(self.replacements) > 0:
			replacement_node = self.replacements.pop()
			self.nodes.append(replacement_node)

		return True

	def split(self):
		if self.min >= self.max:
			log("Cannot split bucket: min >= max")
			return

		mid = (self.min + self.max) / 2
		bucket_1 = Bucket(self.min, mid, self.ksize)
		bucket_2 = Bucket(mid, self.max, self.ksize)

		for n in self.nodes:
			new_bucket = None
			if n.long_id <= mid:
				new_bucket = bucket_1
			else:
				new_bucket = bucket_2
			# new_bucket = bucket_1 if n.long_id <= mid else bucket_2
			new_bucket.add_node(n)

		return bucket_1, bucket_2

	# get all nodes (for lookups)
	def get_nodes(self):
		# bucket is contacted for lookup, update last_visited  
		self.update_last_visited()
		return self.nodes

	def node_count(self):
		return len(self.nodes)

	# return the oldest node contact in this bucket 
	def get_oldest(self):
		return self.nodes[0]

	def random_id(self):
		return random_randint(self.min, self.max)

	def __str__(self):
		output = ""
		for n in self.nodes:
			output += str(n) + "\n"
		return output
