log (getruntime(), "\n")
dht_module = dy_import_module("dht.r2py")
rpc = dy_import_module("rpc.r2py")
util = dy_import_module("util.r2py")
sha = dy_import_module("sha.r2py")
peerfile = dy_import_module("peerfile.r2py")
log (getruntime(), "\n")


# peers = [("router.utorrent.com", 6881), ("bttracker.debian.org", 6881), ("router.bittorrent.com", 6881)]
peers = peerfile.import_peers("peers.txt")

def random_ids_file(filename, n):
  file = openfile(filename, True)
  v = file.readat(20, 0)
  values = list()

  if v == "":
    for i in range(n):
      random_id = util.random_id()
      file.writeat(random_id, i*20)
      values.append(random_id)
    file.close()
    return values  
  else:
    for i in range(n):
      values.append(file.readat(20, i*20))
    file.close()
    return values  

ids = random_ids_file("random_ids.txt", 10)

peers = list()
n = 63101 
i = 0 
while n < 63120:
  peers.append((getmyip(), n+1, ids[i]))
  n += 2 
  i += 1 
# log (peers)

my_ip = getmyip()
MY_PORT = 63101
SETUP_PORT = 63102
timeout = 600   # set timeout to be 10 min for now  
mycontext["setup"] = False 
mycontext["announce"] = False 
mycontext["lookup"] = False 
mycontext["put"] = False 
mycontext["get"] = False 

mycontext["lock"] = createlock()
mycontext["cb"] = None 

DHT_EVENT_SETUP_DONE = 0 
DHT_EVENT_LOOKUP_DONE = 1
DHT_EVENT_ANNOUNCE_DONE = 2
DHT_EVENT_VALUES = 3
DHT_EVENT_GET_DONE = 4 
DHT_EVENT_PUT_DONE = 5
DHT_EVENT_VALUE_ITEM = 6 

class DHTNoResponseError(Exception):
  """ Error starting up the DHT """
class DHTAdvertiseError(Exception):
  """ Error announcing to the DHT """


def callback(event, id, data, data_len=0, res=None):
  mycontext["cb"] = (event, id, data, data_len, res)

  output = "=========================\nRuntime: %s\n" % getruntime()
  if event == DHT_EVENT_SETUP_DONE:
    output += "Setup done. ID: %s\n" % id 
    mycontext["setup"] = True 
  elif event == DHT_EVENT_ANNOUNCE_DONE:
    output += "Announcement done. ID: %s\n" % id 
    mycontext["announce"] = True 
  elif event == DHT_EVENT_LOOKUP_DONE:
    output += "Lookup done. ID: %s\n" % id 
    mycontext["lookup"] = True
  elif event == DHT_EVENT_VALUES:
    output += "Received values. ID: %s\n" % id 
    mycontext["lookup"] = True 
  elif event == DHT_EVENT_PUT_DONE:
    output += "Put done. ID: %s\n" % id 
    mycontext["put"] = True 
  elif event == DHT_EVENT_GET_DONE:
    output += "Get done. ID: %s\n" % id 
    mycontext["get"] = True 
  elif event == DHT_EVENT_VALUE_ITEM:
    output += "Received value item. ID: %s\n" % id 
    mycontext["get"] = True 

  if data_len > 0:
    output += "Nodes (%d): \n" % data_len
    for d in data:
      if isinstance(d, tuple):
        output += d[0] + ": " + str(d[1]) + "\n"
      else:
        output += d.ip + ": " + str(d.port) + "\n"

    output += "-------------------------\n"
    log (output)
  # else we got a data item from get 
  else:
    output += "Data: \n" + str(data) + "\n"
    output += "Response: \n" + str(res) + "\n"
    output += "-------------------------\n"
    log (output)
  # log (mycontext["dht"].router)

def dhtadvertise_setup(my_id, callback, my_version=None, my_port=MY_PORT, setup_port=SETUP_PORT):
  try: 
    mycontext["dht"] = dht_module.DHT(my_id, my_version)
    listen = setup_listen(setup_port, callback)
    createthread(listen)

    for p in peers:
      ip = gethostbyname(p[0])
      port = int(p[1])
      _id = p[2]
      # ping_node is the "hard" way to bootstrap - it actually sends messages to the pinged node 
      # if we don"t have anything in the peersfile yet, use this  
      # mycontext["dht"].ping_node(ip, port, setup_port)

      # Otherwise, we can add nodes to the routing table directly from the peerfile 
      # Beware this can introduce "bad nodes", which will eventually be removed by the routing table 
      if ip == my_ip and (port == setup_port or port == my_port): 
        continue  
      mycontext["dht"].router.add_contact(_id, ip, port, 2)   # 2 for general adding (not reply or query)

  except Exception, e:
    raise Exception("Failed to initialize DHT. " + str(e) + "\n")

  sleep(0.1)
  # log (mycontext["dht"].router.get_all_nodes(), "\n")
  mycontext["dht"].lookups.dht_lookup(my_id, 0, callback, my_version, setup_port)    # lookup my_id 

  # call periodic 
  p = periodic(setup_port)
  createthread(p)


def periodic(port):
  def perio():
    while True:
      if mycontext["dht"].to_sleep <= getruntime():
        mycontext["dht"].periodic(port, callback)
  return perio 

def setup_listen(port, callback=callback):
  def listen():
    starttime = getruntime()
    udpresponsesocket = listenformessage(my_ip, port)

    while getruntime() < starttime + timeout:
      try:  
        remoteip, remoteport, message = udpresponsesocket.getmessage()
        mycontext["dht"].new_message(message, remoteip, remoteport, port, callback)

      except SocketWouldBlockError:
        sleep(0.1)
      except SocketClosedLocal:
        break

    udpresponsesocket.close()

    # save to peerfile 
    contacts = mycontext["dht"].router.get_all_nodes()
    peers = [ n.ip + "," + str(n.port) + "," + n.id + "\n" for n in contacts]
    # log (peers)
    num = peerfile.export_peers(peers, "peers.txt")
    if num > 0:
      log ("Saved %d peers to peerfile.\n" % num)
    else:
      log ("No peers to save.\n")

    if not mycontext["setup"]:
      raise DHTNoResponseError("DHT Timeout: Did not receive enough replies for Node setup.")

    exitall()
  return listen 

def call_listen(operation_type, callback=callback, my_ip=my_ip, my_port=MY_PORT):
  def listen():

    mycontext["lock"].acquire(True)
    starttime = getruntime()

    udpresponsesocket = listenformessage(my_ip, my_port)

    while getruntime() < starttime + timeout:
      if mycontext[operation_type]:
        break 
      try:  
        remoteip, remoteport, message = udpresponsesocket.getmessage()
        mycontext["dht"].new_message(message, remoteip, remoteport, my_port, callback)

      except SocketWouldBlockError:
        sleep(0.1)
      except SocketClosedLocal:
        break

    udpresponsesocket.close()
    mycontext["lock"].release()

    if not mycontext[operation_type]:
      if operation_type == "announce":
        raise DHTAdvertiseError("DHT Timeout: Failed to perform announce_peer.")
      elif operation_type == "lookup":
        raise DHTAdvertiseError("DHT Timeout: Failed to perform get_peers.")
      elif operation_type == "get":
        raise DHTAdvertiseError("DHT Timeout: Failed to perform get.")
      elif operation_type == "put":
        raise DHTAdvertiseError("DHT Timeout: Failed to perform put.")

  return listen 


def dhtadvertise_lookup(my_id, target_id, callback, version=None, my_port=MY_PORT, setup_port=SETUP_PORT):

  target_id = str(target_id)
  if version:
    version = str(version) 

  if not mycontext["setup"]:
    dhtadvertise_setup(my_id, callback, version, my_port, setup_port)
 
  while True:
    if mycontext["setup"]:
      listen = call_listen("lookup", my_port=my_port)
      createthread(listen)

      return mycontext["dht"].lookups.dht_lookup(target_id, 0, callback, version, my_port)
"""
  original BitTorrent method: 
  Announce that the peer, controlling the querying node, is downloading a torrent on a port
  If port is not specified, automatically use the source port of the UDP packets 
"""
def dhtadvertise_announce_once(my_id, target_id, callback, port=MY_PORT, version=None, my_port=MY_PORT, setup_port=SETUP_PORT): 

  if version:
    version = str(version) 
  if port < 1 or port > 65535:
    raise ValueError("Port number must be in range: 1 - 65535.")

  if not mycontext["setup"]:
    dhtadvertise_setup(my_id, callback, version, setup_port)

  while True:
    if mycontext["setup"]:
      listen = call_listen("announce", my_port=my_port)
      createthread(listen)

      return mycontext["dht"].lookups.dht_lookup(target_id, port, callback, version, my_port)

"""
  Value accepted here: any bencoded type (list, dict, string or integer)
"""
def dhtadvertise_put(my_id, value, callback, my_port=MY_PORT, setup_port=SETUP_PORT, **opts): 
  if not value:
    raise ValueError("DHT Put: value is required.")
  if len(util.encoder(value)) >= 1000:
    raise ValueError("DHT Put: values must be under 1000 bytes.")
  if opts:
    if opts.has_key("cas") and not isinstance(opts["cas"], int):
      raise ValueError("Mutable DHT put: cas must be an Integer if provided.")
    if not (opts.has_key("k") and len(opts["k"]) == 32):
      raise ValueError("Mutable DHT put: 32-byte k ed25519 public key is required.")
    if not (opts.has_key("sig") and len(opts["sig"]) == 64):
      raise ValueError("Mutable DHT put: 64-byte signature is required.")
    if opts.has_key("salt") and len(opts["salt"]) > 64:
      raise ValueError("Mutable DHT put: salt must be no larger than 64 bytes if provided.")
    if not opts.has_key("seq"):
      raise ValueError("Mutable DHT put: sequence number is required.")
    if not isinstance(opts["seq"], int):
      raise ValueError("Mutable DHT put: sequence number must be an Integer.")

  # for immutable items, key is the SHA-1 hash of the value stored 
  # for mutable items, key is the SHA-1 hash of k(public key) + salt if salt exists
  key = None 
  if opts:
    if opts.has_key("salt"):
      key = sha.sha_hash(opts["k"] + opts["salt"])
    else:
      key = sha.sha_hash(opts["k"])
  else:
    key = sha.sha_hash(str(value))

  if not mycontext["setup"]:
    dhtadvertise_setup(my_id, callback, setup_port=setup_port)

  while True:
    if mycontext["setup"]:
      listen = call_listen("put", my_port=my_port)
      createthread(listen)

      # 2 for put lookup
      mycontext["dht"].lookups.dht_lookup(key, 2, callback, version=None, my_port=my_port, value=value, opts=opts)
      break 

  # BELOW CODE: for testing only !!!

  # listen = call_listen("put", my_port=my_port)
  # createthread(listen)

  # for p in peers:
  #   tid = util.make_tid("pt", util.make_lid())
  #   token = util.make_token(getmyip(), mycontext["dht"].secret_package[1])
  #   rpc.put(my_id, value, p[0], int(p[1]), tid, token, my_port)

  return key  # return key for future lookup 

def dhtadvertise_get(my_id, key, callback, my_port=MY_PORT, setup_port=SETUP_PORT): 
  if not (isinstance(key, str) and len(key) == 20):
    raise ValueError("DHT get: key must be a 20-byte string.")

  if not mycontext["setup"]:
    dhtadvertise_setup(my_id, callback, setup_port=setup_port)

  while True:
    if mycontext["setup"]:
      listen = call_listen("get", my_port=my_port)
      createthread(listen)

      # 1 for get lookup
      return mycontext["dht"].lookups.dht_lookup(key, 1, callback, version=None, my_port=my_port)

  # BELOW CODE: for testing only !!!
  # listen = call_listen("get", my_port=my_port)
  # createthread(listen)

  # for p in peers:
  #   tid = util.make_tid("gt", util.make_lid())
  #   rpc.get(my_id, id, p[0], int(p[1]), tid, setup_port)


# if the values we're looking for exist in local storage 
def dhtadvertise_local_lookup(id):
  values = dht.storage.retrieve(id)
  if values:
    return values 

def id_from_file(filename):
  file = openfile(filename, True)
  value = file.readat(20, 0)
  # if file has no content yet 
  if value == "":
    random_id = util.random_id()
    file.writeat(random_id, 0)
    file.close()
    return random_id 
  else:
    file.close()
    return value 

# expose the ping method to advertise users 
def dhtadvertise_ping(ip, port):
  dht.ping_node(ip, port)


# random module for testing only 
random = dy_import_module("random.r2py")
rand = random.random_randombytes(20)
# id = id_from_file("example.id")
# UDP Port range: 63100, 63201
# log (ids, "\n")

if callfunc == "initialize":
  # port, setup port 
  if len(callargs) == 2:
    my_p = int(callargs[0])
    setup_p = int(callargs[1])
    log (my_p, " ", setup_p, "\n")
    index = (my_p - 63101) / 2 
    # dhtadvertise_setup(ids[index], callback, my_version="AD\0\0", my_port=my_p, setup_port=setup_p)
    # dhtadvertise_lookup(ids[index], rand, callback, "AD\0\0", my_p, setup_p)
    # dhtadvertise_announce_once(ids[index], rand, callback, port=5000, version="AD\0\0", my_port=my_p, setup_port=setup_p)
    
    # mycontext["dht"] = dht_module.DHT(ids[index], "AD\0\0")
    # listen = setup_listen(setup_p)
    # createthread(listen)

    key = dhtadvertise_put(rand, {"a": [0, 1]}, callback, my_p)

    while True: 
      if mycontext["put"]:
        log (key, "\n")
        dhtadvertise_get(ids[index], key, callback)
        break 

  else:
    raise ValueError("must call dht_advertise.r2py with port arguments.")
