dht_module = dy_import_module("dht.r2py")
rpc = dy_import_module("rpc.r2py")
util = dy_import_module("util.r2py")
sha = dy_import_module("sha.r2py")
peerfile = dy_import_module("peerfile.r2py")

# peers = [("router.utorrent.com", 6881), ("bttracker.debian.org", 6881), ("router.bittorrent.com", 6881)]
# peers = [("192.171.20.108", 63102), ("router.utorrent.com", 6881)]
peers = peerfile.import_peers("peers.txt")

my_ip = getmyip()
my_port = 63101
setup_port = 63102
timeout = 600 
mycontext["setup"] = False 
mycontext["announce"] = False 
mycontext["lookup"] = False 
mycontext["put"] = False 
mycontext["get"] = False 

mycontext["lock"] = createlock()

DHT_EVENT_SETUP_DONE = 0 
DHT_EVENT_LOOKUP_DONE = 1
DHT_EVENT_ANNOUNCE_DONE = 2
DHT_EVENT_VALUES = 3
DHT_EVENT_GET_DONE = 4 
DHT_EVENT_PUT_DONE = 5
DHT_EVENT_VALUE_ITEM = 6 

class DHTNoResponseError(Exception):
  """ Error starting up the DHT """
class DHTAdvertiseError(Exception):
  """ Error announcing to the DHT """


def dhtadvertise_setup(my_id, my_version=None):
  try: 
    mycontext["dht"] = dht_module.DHT(my_id, my_version)
    # listen = call_listen("setup")
    createthread(setup_listen)

    for p in peers:
      ip = gethostbyname(p[0])
      port = int(p[1])
      _id = p[2]
      # ping_node is the "hard" way to bootstrap - it actually sends messages to the pinged node 
      # if we don"t have anything in the peersfile yet, use this  
      # mycontext["dht"].ping_node(ip, port, setup_port)

      # Otherwise, we can add nodes to the routing table directly from the peerfile 
      # Beware this can introduce "bad nodes", which will eventually be removed by the routing table 
      mycontext["dht"].router.add_contact(_id, ip, port, 2)   # 2 for general adding (not reply or query)

  except Exception, e:
    raise Exception("Failed to initialize DHT. " + str(e) + "\n")

  sleep(0.1)

  mycontext["dht"].lookups.dht_lookup(my_id, 0, callback, my_version, setup_port)    # lookup my_id 

  # call periodic 
  p = periodic(setup_port)
  createthread(p)


def periodic(port):
  def perio():
    while True:
      if mycontext["dht"].to_sleep <= getruntime():
        mycontext["dht"].periodic(port, callback)
  return perio 

def setup_listen():

  starttime = getruntime()
  udpresponsesocket = listenformessage(my_ip, setup_port)

  while getruntime() < starttime + timeout:
    try:  
      remoteip, remoteport, message = udpresponsesocket.getmessage()
      mycontext["dht"].new_message(message, remoteip, remoteport, setup_port, callback)

    except SocketWouldBlockError:
      sleep(0.1)
    except SocketClosedLocal:
      break

  udpresponsesocket.close()

  # save to peerfile 
  contacts = mycontext["dht"].router.get_all_nodes()
  peers = [ n.ip + "," + str(n.port) + "," + n.id + "\n" for n in contacts]
  num = peerfile.export_peers(peers, "peers.txt")
  log ("Saved %d peers to peerfile.\n" % num)

  if not mycontext["setup"]:
    raise DHTNoResponseError("DHT Timeout: Did not receive enough replies for Node setup.")

  exitall()

def call_listen(operation_type):
  def listen():
    mycontext["lock"].acquire(True)
    starttime = getruntime()
    udpresponsesocket = listenformessage(my_ip, my_port)

    while getruntime() < starttime + timeout:
      # if operation_type == "setup" and mycontext[operation_type]:
      #   break 
      try:  
        remoteip, remoteport, message = udpresponsesocket.getmessage()
        mycontext["dht"].new_message(message, remoteip, remoteport, callback=callback)

      except SocketWouldBlockError:
        sleep(0.1)
      except SocketClosedLocal:
        break

    udpresponsesocket.close()
    mycontext["lock"].release()

    if not mycontext[operation_type]:
      if operation_type == "announce":
        raise DHTAdvertiseError("DHT Timeout: Failed to perform announce_peer.")
      elif operation_type == "lookup":
        raise DHTAdvertiseError("DHT Timeout: Failed to perform get_peers.")
      elif operation_type == "get":
        raise DHTAdvertiseError("DHT Timeout: Failed to perform get.")
      elif operation_type == "put":
        raise DHTAdvertiseError("DHT Timeout: Failed to perform put.")

  return listen 


def callback(event, id, data, data_len=0, res=None):
  output = "=========================\nRuntime: %s\n" % getruntime()
  if event == DHT_EVENT_SETUP_DONE:
    output += "Setup done. ID: %s\n" % id 
    mycontext["setup"] = True 
  elif event == DHT_EVENT_ANNOUNCE_DONE:
    output += "Announcement done. ID: %s\n" % id 
    mycontext["announce"] = True 
  elif event == DHT_EVENT_LOOKUP_DONE:
    output += "Lookup done. ID: %s\n" % id 
    mycontext["lookup"] = True
  elif event == DHT_EVENT_VALUES:
    output += "Received values. ID: %s\n" % id 
    mycontext["lookup"] = True 
  elif event == DHT_EVENT_PUT_DONE:
    output += "Put done. ID: %s\n" % id 
    mycontext["put"] = True 
  elif event == DHT_EVENT_GET_DONE:
    output += "Get done. ID: %s\n" % id 
    mycontext["get"] = True 
  elif event == DHT_EVENT_VALUE_ITEM:
    output += "Received value item. ID: %s\n" % id 
    mycontext["get"] = True 

  if data_len > 0:
    output += "Nodes (%d): \n" % data_len
    for d in data:
      if isinstance(d, tuple):
        output += d[0] + ": " + str(d[1]) + "\n"
      else:
        output += d.ip + ": " + str(d.port) + "\n"

    output += "-------------------------\n"
    log (output)
  # else we got a data item from get 
  else:
    output += "Data: \n" + str(data) + "\n"
    output += "Response: \n" + str(res) + "\n"
    output += "-------------------------\n"
    log (output)


def dhtadvertise_lookup(my_id, target_id, callback, version=None):

  target_id = str(target_id)
  if version:
    version = str(version) 

  if not mycontext["setup"]:
    dhtadvertise_setup(my_id, version)
 
  while True:
    if mycontext["setup"]:
      listen = call_listen("lookup")
      createthread(listen)

      mycontext["dht"].lookups.dht_lookup(target_id, 0, callback, version)
      break 

"""
  original BitTorrent method: 
  Announce that the peer, controlling the querying node, is downloading a torrent on a port
  If port is not specified, automatically use the source port of the UDP packets 
"""
def dhtadvertise_announce_once(my_id, target_id, callback, port=my_port, version=None): 
  if version:
    version = str(version) 
  if port < 1 or port > 65535:
    raise ValueError("Port number must be in range: 1 - 65535.")

  if not mycontext["setup"]:
    dhtadvertise_setup(my_id, version)

  while True:
    if mycontext["setup"]:
      listen = call_listen("announce")
      createthread(listen)

      mycontext["dht"].lookups.dht_lookup(target_id, port, callback, version)
      break 

"""
  Value accepted here: any bencoded type (list, dict, string or integer)
"""
def dhtadvertise_put(my_id, value, callback, **opts): 
  if not value:
    raise ValueError("DHT Put: value is required.")
  if len(util.encoder(value)) >= 1000:
    raise ValueError("DHT Put: values must be under 1000 bytes.")
  if opts:
    if opts.has_key("cas") and not isinstance(opts["cas"], int):
      raise ValueError("Mutable DHT put: cas must be an Integer if provided.")
    if not (opts.has_key("k") and len(opts["k"]) == 32):
      raise ValueError("Mutable DHT put: 32-byte k ed25519 public key is required.")
    if not (opts.has_key("sig") and len(opts["sig"]) == 64):
      raise ValueError("Mutable DHT put: 64-byte signature is required.")
    if opts.has_key("salt") and len(opts["salt"]) > 64:
      raise ValueError("Mutable DHT put: salt must be no larger than 64 bytes if provided.")
    if not opts.has_key("seq"):
      raise ValueError("Mutable DHT put: sequence number is required.")
    if not isinstance(opts["seq"], int):
      raise ValueError("Mutable DHT put: sequence number must be an Integer.")

  # for immutable items, key is the SHA-1 hash of the value stored 
  # for mutable items, key is the SHA-1 hash of k(public key) + salt if salt exists
  key = None 
  if opts:
    if opts.has_key("salt"):
      key = sha.sha_hash(opts["k"] + opts["salt"])
    else:
      key = sha.sha_hash(opts["k"])
  else:
    key = sha.sha_hash(value)

  if not mycontext["setup"]:
    dhtadvertise_setup(my_id)

  while True:
    if mycontext["setup"]:
      listen = call_listen("put")
      createthread(listen)

      # 2 for put lookup
      mycontext["dht"].lookups.dht_lookup(key, 2, callback, version=None, value=value, opts=opts)
      break 

  return key  # return key for future lookup 

def dhtadvertise_get(my_id, key, callback): 
  if not (isinstance(key, str) and len(key) == 20):
    raise ValueError("DHT get: key must be a 20-byte string.")

  if not mycontext["setup"]:
    dhtadvertise_setup(my_id)

  while True:
    if mycontext["setup"]:
      listen = call_listen("get")
      createthread(listen)

      # 1 for get lookup
      mycontext["dht"].lookups.dht_lookup(key, 1, callback, version=None)
      break 

# if the values we're looking for exist in local storage 
def dhtadvertise_local_lookup(id):
  values = dht.storage.retrieve(id)
  if values:
    return values 

def id_from_file(filename):
  file = openfile(filename, True)
  value = file.readat(20, 0)
  # if file has no content yet 
  if value == "":
    random_id = util.random_id()
    file.writeat(random_id, 0)
    file.close()
    return random_id 
  else:
    file.close()
    return value 

# expose the ping method to advertise users 
def dhtadvertise_ping(ip, port):
  dht.ping_node(ip, port)
