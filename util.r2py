sha = dy_import_module("sha.r2py")
random = dy_import_module("random.r2py")

LID_BIT_SIZE = 16 
ROTATE_SECRET_INTERVAL = 5 * 60   # rotate secret every 5 minutes 
SECRET_SIZE = 8

# generate random 20 bytes for use as a DHT node id 
def random_id():
  return random.random_randombytes(20)

# generate a 2-byte (16 bit) lookup id (lid)
def make_lid():
  return random.random_nbit_int(LID_BIT_SIZE)

# generate a 4-byte transaction id string  
def make_tid(prefix, sequence):
  output = ""
  for n in prefix:
    output += chr(ord(n) & 0xFF) 
  output += int_to_bytes(sequence)
  return output 

def tid_match(tid, prefix):
  """
  <Purpose>
    check if transaction id (tid) matches a certain 2-character prefix (for example, "fn" for find_node)
    return the sequence taken from tid if matches, else return False 

  """
  if len(tid) > 2 and tid[0] == chr(ord(prefix[0]) & 0xFF) and tid[1] == chr(ord(prefix[1]) & 0xFF):
    return tid[2:]
  else:
    return False  

def rotate_secret(secret=None):
  """
  <Purpose>
    Generate and rotate our DHT secret
    tokens are rotated every 5 min; tokens up to 10 min old are accepted 
    return the old secret, the newly generated secret, and next rotate time 
  """
  old_secret = None  
  if secret:
    old_secret = str(secret)
  # 8-byte secret 
  secret = random.random_randombytes(SECRET_SIZE)
  rotate_secret_time = getruntime() + ROTATE_SECRET_INTERVAL 

  return (old_secret, secret, rotate_secret_time)

# generate 16-byte tokens by sha-1 hashing ip concatenated with secret 
def make_token(ip, secret):
  return sha.sha_hash(str(ip) + secret)


def token_match(token, ip, old_secret, secret):
  """
  <Purpose>
    check if token matches our ip and secret. 
    Note: both secret and old_secret are checked 
    If match, return True, otherwise return False 
  """
  if old_secret:
    old_hash = sha.sha_hash(str(ip) + old_secret)
    if old_hash == token: 
      return True 
  if secret:
    now_hash = sha.sha_hash(str(ip) + secret)
    if now_hash == token: 
      return True 

  return False 

# get the XOR distance between two numbers 
def xor_distance(num1, num2):
  return num1 ^ num2 


def compare_distance(target, num1, num2):
  """
  <Purpose>
    compare the XOR distances between target and two other numbers  
    if positive, distance from num1 is greater than distance from num2 
  """
  return xor_distance(target, num1) - xor_distance(target, num2)

# convert the dot-seperated ip string to a 4-byte string 
def ip_as_bytes(ip):
  ip_as_bytes = ''.join(map(chr,map(int,ip.split('.'))))
  return ip_as_bytes

def int_to_bytes(long_int):
  """
  <Purpose>
    Convert a long integer to a byte string.
    Used by random_randombytes to convert integers recovered
    from random floats into its byte representation.
    Used by random_randombytes, random_randombytes is responsible
    for padding any required binary zeroes that are lost in the
    conversion process.
  """

  long_int = long(long_int)
  byte_string = ''
  temp_int = 0

  # Special case to ensure that a non-empty string
  # is always returned.
  if long_int == 0:
    return '\000'

  while long_int > 0:
    # Use a bitwise AND to get the last 8 bits from the long.
    #    long_int  -->   1010... 010000001 (base 2)
    #    0xFF      -->            11111111
    #              _______________________
    #  Bitwise AND result -->     10000001
    tmp_int = long_int & 0xFF
    # Place the new character at the front of the string.
    byte_string = "%s%s" % (chr(tmp_int), byte_string)
    # Bitshift the long because the trailing 8 bits have just been read.
    long_int = long_int >> 8

  return byte_string

# convert an iterable collection of bytes to integer 
def bytes_to_int(bytes):
  n = 0
  # read from bytes and add to n 
  for b in bytes:
    n = n * 256 + ord(b)
  return n

def swap_endianess(num):
  return ((num & 0xFF) << 8) | ((num & 0xFF00) >> 8)

# check if string length exceeds a certain max. 
def length_check(index, length, buf_len):
  if index + length > buf_len:
    log ("Failed length check.\n")
    return False 
  return True 

def parse_message(buf, tid_len=8, token_len=20, nodes_len=16*26, values_len=16*6): 
  """
  <Purpose>
    parse incoming rpc messages. 
    some constraints: 
      Max tid length: 8 
      Max token length: 20 
      Max number of nodes to receive: 16 
      Max number of peers to receive: 16 

  <Returns>
    A tuple containing a collection of parsed information, or in the case of 
    GET/PUT, return the decoded message directly 

  <Note>
    This method is adapted from jech's DHT implementation at https://github.com/jech/dht
    Note: A "cleaner" and possibly more efficient way is to use our own decoder method for all messages 
  """

  buf_len = len(buf)
  sender_id = info_hash = target = token = ""
  tid = ""
  nodes = ""
  values = ""
  port = 0 

  msg_type = -1 

  if buf.find("1:y1:r") > -1:
    msg_type = "REPLY"
  elif buf.find("1:y1:e") > -1:
    msg_type = "ERROR"    
  elif buf.find("1:y1:q") == -1:   # if message type is neither reply nor query, it's a wrong type 
    msg_type = -1 
  elif buf.find("1:q4:ping") > -1:
    msg_type = "PING"
  elif buf.find("1:q9:find_node") > -1:
    msg_type = "FIND_NODE"
  elif buf.find("1:q9:get_peers") > -1:
    msg_type = "GET_PEERS"
  elif buf.find("1:q13:announce_peer") > -1:
    msg_type = "ANNOUNCE_PEER"
  else:
    return decoder(buf)   # if it's a put/get message, return the decoded dictionary object 
  
  if msg_type == -1:    # if query is unknown, return the buf string 
    return buf 

  # parse tid if it exists and adheres to our rule 
  p = buf.find("1:t")
  if p > -1:
    l = int(buf[p+3])
    if 0 < l <= tid_len and buf[p+4] == ":":
      k = p+5
      while k < buf_len and not (buf[k] == "1" and buf[k+1] == ":"):
        tid += buf[k]
        k += 1 
      tid_len = len(tid)
      # log ("tid(tid_len): ", tid, " (", tid_len, ") \n")
    else:
      tid_len = 0 
  else:
    tid_len = 0 

  # parse id if exists 
  p = buf.find("2:id20:")
  if p > -1:
    if length_check(p+7, 20, buf_len):
      sender_id = buf[p+7:p+7+20]
      # log ("sender id: ", sender_id, "\n")
    else:
      sender_id = 0 

  # parse infohash if exists 
  p = buf.find("9:info_hash20:")
  if p > -1:
    if length_check(p+14, 20, buf_len):
      info_hash = buf[p+14:p+14+20]
      log ("infohash: ", info_hash, "\n")
    else:
      info_hash = 0 

  # parse port number if exists 
  p = buf.find("porti")
  if p > -1:
    n_str = ""
    q = p+5
    while q < buf_len and buf[q].isdigit():
      n_str += buf[q]
      q += 1 
    n = int(n_str)
    if buf[q] and buf[q] == 'e' and 0 < n < 0x10000:
      # log ("port: ", n, "\n")
      port = n

  # parse target if exists 
  p = buf.find("6:target20:")
  if p > -1:
    if length_check(p+11, 20, buf_len):
      target = buf[p+11:p+11+20]
      # log("target: ", target, "\n")
    else:
      target = 0 

  # parse token if exists 
  p = buf.find("5:token")
  if p > -1:
    l_str = ""
    q = p+7 
    while q < buf_len and buf[q].isdigit():
      l_str += buf[q]
      q += 1 
    l = int(l_str)
    if (0 < l <= token_len and buf[q] == ":" and length_check(p+7, token_len, buf_len)):
      token = buf[q+1:q+1+l]
      token_len = l 
      # log ("token(token_len): ", token, " (", token_len, ") \n")
    else: 
      token_len = 0 
  else:
    token_len = 0

  # parse nodes string if exists 
  p = buf.find("5:nodes")
  if p > -1:
    l_str = ""
    q = p+7 
    while q < buf_len and buf[q].isdigit():
      l_str += buf[q]
      q += 1 
    l = int(l_str)
    if 0 < l <= nodes_len and buf[q] == ":":
      k = q+1
      while k < buf_len and k < l + (q+1):
        nodes += buf[k]
        k += 1 
      nodes_len = len(nodes)
      # log ("nodes(nodes_len): ", nodes, " (", nodes_len, ") \n")
    else:
      nodes_len = 0 
  else:
    nodes_len = 0  

  # parse values if exist 
  p = buf.find("6:valuesl")
  if p > -1:
    q = p+9 
    while True: 
      l_str = ""
      l = 0 
      while q < buf_len and buf[q].isdigit():
        l_str += buf[q]
        q += 1 
      if l_str:
        l = int(l_str)
      if q < buf_len and buf[q] == ":":
        if l == 6:
          k = q+1
          while not ((buf[k] == "6" and buf[k+1] == ":") or buf[k] == "e"):
            values += buf[k]
            k += 1 
          q = k
        else:
          log ("Received weird value -- %d bytes.\n" % l )
      else:
        break 
    if q < buf_len and buf[q] == "e":
      values_len = len(values)
      # log ("values(len): ", values, " (", values_len, ") \n")
    else:
      log ("Unexpected end for values.\n")
  else:
    values_len = 0 

  return (msg_type, tid, tid_len, sender_id, info_hash, target, port, 
            token, token_len, nodes, nodes_len, values, values_len)

def invalid_address(ip, port):
  """
  <Purpose>
    validate the given address (ip, port pair)
    the address is invalid if:
    port is 0, ip starts with 0, 127, or a number greater than 224. 
  """
  ip_list = [int(n) for n in ip.split(".")]
  if port == 0 or ip[0] == "0" or ip_list[0] == 127 or ip_list[0] > 224:
    return True 
  return False  


def encoder(obj):
  """
  <Purpose>
    Bencode encode method. 

    Note: 
    The Bencode encoder and decoder functions here are inspired by: 
    Utku Demir's bencoder at https://github.com/utdemir/bencoder/
  """

  if isinstance(obj, int):
    return "i" + str(obj) + "e"
  elif isinstance(obj, str):
    return str(len(obj)) + ":" + obj 
  elif isinstance(obj, list):
    return "l" + "".join([encoder(n) for n in obj]) + "e"
  elif isinstance(obj, dict):
    all_key_str = True 
    for n in obj.keys():
      if not isinstance(n, str):
        all_key_str = False 
        break 
    if all_key_str:
      items = list(obj.items())
      items.sort()
      return_val = "d"
      for item in items:
        for n in item:
          return_val += encoder(n)
      return_val += "e"
      return return_val 
    else:
      raise ValueError("Dictionary keys should be of type string.")
  else:
    raise ValueError("Allowed Bencode types: int, string, list, dict. Not: ", type(obj))

def decoder(s):
  """
  <Purpose>
    Bencode decode method. 

    Note: 
    The Bencode encoder and decoder functions here are inspired by: 
    Utku Demir's bencoder at https://github.com/utdemir/bencoder/
  """
  
  if not isinstance(s, str):
    raise ValueError("Only string type can be decoded.")

  def _decode(i):
    if s[i] == "i":
      j = i + 1 
      int_val = "" 
      while s[j].isdigit() and not s[j] == "e":
        int_val += s[j]
        j += 1 
      if not s[j] == "e":
        log("Malformed input. j: %d\n" % j)
      # skip past the "e" signaling end of int 
      j += 1 
      return int(int_val), j
    elif s[i] == "l" or s[i] == "d":
      l = list()
      j = i + 1 
      while j < len(s):
        elem, j = _decode(j)
        l.append(elem)
        # if it's end of collection signaled by "e", break 
        if j < len(s) and s[j] == "e":
          j += 1
          break 
      if s[i] == "l":
        return l, j  
      else:
        return_dict = dict()
        n = 0 
        while n + 1 < len(l):
          return_dict[l[n]] = l[n + 1]
          n += 2 
        return return_dict, j   
    elif s[i].isdigit():
      length = "" 
      while s[i].isdigit() and not s[i] == ":":
        length += s[i]
        i += 1 
      length = int(length) 
      i += 1
      val = s[i: i + length]
      return val, i + length
    else:
      log("Malformed input: %s\n" % s[i:])

  return_val, i = _decode(0)
  if i < len(s):
    log ("Malformed input. i: %d/%d\n" %(i, len(s)))

  return return_val 
