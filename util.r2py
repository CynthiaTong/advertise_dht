dy_import_module_symbols("time.r2py")
dy_import_module_symbols("sha.r2py")
dy_import_module_symbols("random.r2py")

def get_time():
	timeport = list(getresources()[0]["connport"])[0]
	time_updatetime(timeport)
	return time_gettime()

# 4-byte transaction ids ??? without using bytearray? 
def make_tid(prefix, sequence):
	output = [ord(n) & 0xFF for n in prefix]
	# log (int(sequence).bit_length(),"\n")
	binary_seq = "{0:b}".format(sequence)[:16] # get the first 16 bits (2 bytes) of the integer 
	# log (len(binary_seq), "\n")
	output.append(int(binary_seq, 2))
	# log (output[2].bit_length(), "\n")
	# log(output, "\n")
	# total_bytes = 0 
	# for n in output:
	# 	total_bytes += (n.bit_length() + 7) // 8 
	# log(total_bytes, "\n")

	# return a character list 
	return output 

# return the sequence taken from tid if matches, else return -1 
def tid_match(tid, prefix):
	if tid[0] == ord(prefix[0]) and tid[1] == ord(prefix[1]):
		return tid[2]
	else:
		return -1 

ROTATE_SECRET_INTERVAL = 5 * 60
TOKEN_SIZE = 8
SECRET_SIZE = 8

# tokens are rotated every 5 min; tokens up to 10 min old are accepted 
def rotate_secret(secret=None):
	old_secret = None 
	if secret:
		old_secret = str(secret)

	secret = random_randombytes(SECRET_SIZE)
	rotate_secret_time = get_time() + ROTATE_SECRET_INTERVAL 

	return (old_secret, secret, rotate_secret_time)

def make_token(ip, secret):
	return sha_hash(str(ip) + secret)

def token_match(token, ip, old_secret, secret):
	if old_secret:
		old_hash = sha_hash(str(ip) + old_secret)
		if old_hash == token: return True 
	now_hash = sha_hash(str(ip) + secret)
	if now_hash == token: return True 

	return False 

LID_BIT_SIZE = 16 
def make_lid():
	return random_nbit_int(LID_BIT_SIZE)
