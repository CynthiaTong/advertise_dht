dy_import_module_symbols("time.r2py")
dy_import_module_symbols("sha.r2py")
dy_import_module_symbols("random.r2py")

def get_time():
	timeport = list(getresources()[0]["connport"])[0]
	time_updatetime(timeport)
	return time_gettime()

# 4-byte transaction id string  
def make_tid(prefix, sequence):
	output = ""
	for n in prefix:
		output += chr(ord(n) & 0xFF) 
	binary_seq = "{0:b}".format(sequence)[:16] # get the first 16 bits (2 bytes) of the integer 
	output += str(int(binary_seq, 2))
	# log(output, "\n")
	# return a character / int list 
	return output 

# return the sequence taken from tid if matches, else return -1 
def tid_match(tid, prefix):
	if tid[0] == chr(ord(prefix[0]) & 0xFF) and tid[1] == chr(ord(prefix[1]) & 0xFF):
		return tid[2:]
	else:
		return -1 


ROTATE_SECRET_INTERVAL = 5 * 60
TOKEN_SIZE = 8
SECRET_SIZE = 8

# tokens are rotated every 5 min; tokens up to 10 min old are accepted 
def rotate_secret(secret=None):
	old_secret = None 
	if secret:
		old_secret = str(secret)

	secret = random_randombytes(SECRET_SIZE)
	rotate_secret_time = get_time() + ROTATE_SECRET_INTERVAL 

	return (old_secret, secret, rotate_secret_time)

# 16 byte token 
def make_token(ip, secret):
	return sha_hash(str(ip) + secret)

def token_match(token, ip, old_secret, secret):
	if old_secret:
		old_hash = sha_hash(str(ip) + old_secret)
		if old_hash == token: return True 
	now_hash = sha_hash(str(ip) + secret)
	if now_hash == token: return True 

	return False 

LID_BIT_SIZE = 16 
def make_lid():
	return random_nbit_int(LID_BIT_SIZE)

# Converts some number of random bytes into a number
# Treats random data as an unsigned long.
def string_to_long(data, bytes):
  # Store the number
  num = 0L
  offset = 0
  for char in data:
    num |= ord(char) << offset * 8
    offset += 1

  return num

def xor_distance(num1, num2):
	return num1 ^ num2 

# if positive, dist from num1 > dist from num2 
def compare_distance(target, num1, num2):
	return xor_distance(target, num1) - xor_distance(target, num2)

def ip_as_bytes(ip):
	ip_as_bytes = ''.join(map(chr,map(int,ip.split('.'))))
	return ip_as_bytes


def htons(num):
	# if integer is 2-byte 
	if (num.bit_length() + 7) // 8 == 2:
		n = (num & 0xFF << 8) | (num & 0xFF00 >> 8)
		return _random_long_to_bytes(n)
	log ("htons: integer is not 2 bytes.\n")
	return -1 

def ntohs(num):
	if (num.bit_length() + 7) // 8 == 2:
		n = (num & 0xFF << 8) | (num & 0xFF00 >> 8)
		return _random_long_to_bytes(n)
	log ("ntohs: integer is not 2 bytes.\n")
	return -1 
