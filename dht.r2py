node = dy_import_module("node.r2py")
routing = dy_import_module("routing.r2py")
rpc = dy_import_module("rpc.r2py")
lookup = dy_import_module("lookup.r2py")
storage = dy_import_module("storage.r2py")
util = dy_import_module("util.r2py")
random = dy_import_module("random.r2py")


TOKEN_SIZE = 16 
K_SIZE = 8 
DHT_EVENT_VALUES = 1

class DHT:

  def __init__(self, dht_id):
    self.id = dht_id
    self.long_id = util.string_to_long(self.id)

    self.router = routing.RoutingTable(self.id, K_SIZE) 
    self.lookups = lookup.DHTLookup(self.id, self.router)
    self.storage = storage.Storage(self.id) 
    self.secret_package = util.rotate_secret() 
    self.refresh_buckets_time = getruntime() + random.random_int_below(3)
    self.to_sleep = getruntime()

    # bucket_grow_time for mybucket maintenance? 
    # token_bucket_time for rate control?

  def new_message(self, buf, source_ip, source_port, callback=None):

    if buf and len(buf) > 0:
      if util.invalid_address(source_ip, source_port):
        return self.periodic(callback)

      msg = util.parse_message(buf)
      if msg == -1:
        return self.periodic(callback)

      # log (msg, "\n")
      (msg_type, tid, tid_len, sender_id, info_hash, target, port, token, token_len,
      nodes, nodes_len, values, values_len) = msg 

      nodes_len = int(nodes_len)
      values_len = int(values_len)
      token_len= int(token_len)

      if msg_type == "ERROR" or util.string_to_long(sender_id) == 0:
        log ("Faulty message - unparseable: \n", buf, "\n")
        return self.periodic(callback)

      if sender_id == self.id and source_ip == getmyip():
        log ("Received message from self. weird.\n")
        return self.periodic(callback)

      ## Rate control ?? 

      if msg_type == "REPLY":
        if not tid_len == len(tid):
          log ("Broken tid: ", tid, "\n")
          return self.periodic(callback)

        if util.tid_match(tid, "pn"):
          log ("Pong!\n")
          self.router.add_contact(sender_id, source_ip, source_port, 0) # 0 for reply

        elif util.tid_match(tid, "gp") or util.tid_match(tid, "fn"):
          lids = (util.tid_match(tid, "gp") , util.tid_match(tid, "fn"))
          # log ("LIDS: ", lids, "\n")
          # try to find among existing lookups by searching lid 
          for lid in lids:
            if lid:
              lookup_ids = self.lookups.find_lookup_by_tid(lid).get_all_ids()
              lookup = self.lookups.find_lookup_by_tid(lid) 
              log ("Got %d nodes for tid: %s\n" % (nodes_len/26, tid))
              # check nodes_len is normal 
              if not nodes_len % 26 == 0:
                log ("Unexpected length for node info!\n")
              elif lid == lids[0] and lookup == None:
                log ("Unknown lookup!\n")
                self.router.add_contact(sender_id, source_ip, source_port, 1) # 1 for query (msg)
              else: # nodes_len normal & existing lookup - it's a proper reply 
                self.router.add_contact(sender_id, source_ip, source_port, 0) # 0 for reply 
                i = 0 
                while i <= nodes_len - 26:
                  n = nodes[i:i+26]
                  # convert id, ip and port to host order and readable format 
                  n_id = ""
                  for x in n[:20]:
                    n_id += chr(int(x))

                  ip_strs = list()
                  for x in n[20:24]:
                    ip_strs.append(str(x))
                  n_ip = ".".join(ip_strs)

                  n_port = util.bytes_to_int(n[24:])  # convert port bytes back to an integer
                  i += 26 
                  # log (n_ip, ": ", n_port, "\n")
                  if n_id == self.id:
                    continue;
                  self.router.add_contact(n_id, n_ip, n_port, 2) # 2 for arbitrary msgs 

                  # insert into the corresponding lookup  
                  if lookup: 
                    lookup.insert(n_id, n_ip, n_port)
                  # self.ping_node(n_ip, n_port)

                if lookup: 
                  # 1 means this node has replied 
                  lookup.insert(sender_id, source_ip, source_port, 1, token, token_len)
                  # since we got a reply, send out another round of lookup requests
                  self.lookups.lookup_step(lookup, callback)
                  # check if we got the exact same results after this reply                   
                  lookup_nodes = lookup.get_nodes()
                  stable = len(lookup_ids) == len(lookup_nodes)
                  for n in lookup_nodes:
                    if not n.id in lookup_ids:
                      # if there's a new node, clear stable results 
                      self.lookups.stable_results = 0
                      stable = False 
                      break 
                  # otherwise, increment stable results: we are left with the same results as last time
                  if stable: 
                    self.lookups.stable_results += 1 

                  log ("--------- LOOKUP ---------\n", lookup.print_good_nodes(), "stable results: %d\n" % self.lookups.stable_results)
                  # if lookup results have stablized (invarient for > 10 times) and there are some results 
                  # return as finished 
                  if self.lookups.stable_results >= 10 and len(lookup.get_nodes()) > 0:
                    self.lookups.lookup_finished(lookup, callback)

          if values_len > 0 and lids[0]:
            log ("Got %d values!\n" % (values_len/6))
            filtered_values = list()
            i = 0 
            while i < values_len:
              v = values[i:i+6]
              ip_strs = list()
              for x in v[0:4]:
                ip_strs.append(str(x))
              v_ip = ".".join(ip_strs)

              v_port = util.bytes_to_int(v[4:])  # convert port bytes back to an integer
              i += 6
              filtered_values.append((v_ip, v_port))
              # log (v_ip, ": ", v_port, "\n")
            if callback:
              return callback(DHT_EVENT_VALUES, lookup.id, filtered_values, len(filtered_values))

        elif util.tid_match(tid, "ap"):  
          log ("Got reply to announce_peer!\n")
          lid = util.tid_match(tid, "ap")
          lookup = self.lookups.find_lookup_by_tid(lid) 
          if lookup == None:
            log ("Unknown lookup!\n")
            self.router.add_contact(sender_id, source_ip, source_port, 1) # 1 for query (msg)
          else:
            self.router.add_contact(sender_id, source_ip, source_port, 0) # 0 for reply 
            for n in lookup:
              if n.id == sender_id:
                n.last_req = 0 
                n.replied = 1 
                n.last_replied = getruntime()
                n.acked = 1 
                n.pinged = 0 
                break 

            self.lookups.lookup_get_peers(lookup)

        else:
          log ("Unexpected reply: \n%s (%d)\n" % (buf, len(buf)))

      elif msg_type == "PING":
        log ("Ping!\n")
        self.router.add_contact(sender_id, source_ip, source_port, 1) # 1 for msg 
        log ("Sending pong.\n")
        rpc.pong(self.id, source_ip, source_port, tid, tid_len)

      elif msg_type == "FIND_NODE":
        log ("Find node!\n")
        self.router.add_contact(sender_id, source_ip, source_port, 1) # 1 for msg 
        log ("Sending closest node to find_node req.\n")
        rpc.send_closest_nodes(self.router, self.id, source_ip, source_port, tid, tid_len, target)

      elif msg_type == "GET_PEERS":
        log ("Get peers!\n")
        self.router.add_contact(sender_id, source_ip, source_port, 1) # 1 for msg 
        if util.string_to_long(info_hash) == 0:
          log ("Got get_peers with no info_hash\n")
          rpc.send_error(source_ip, source_port, tid, tid_len, 
                              203, "Get_peers with no infohash.")
        else:
          peers_list = self.storage.retrieve(info_hash)
          token = util.make_token(source_ip, self.secret_package[1])
          if peers_list:
            log ("Sending found peers.\n")
            rpc.send_closest_nodes(self.id, source_ip, source_port, tid, tid_len, info_hash, 
                                        token, TOKEN_SIZE, peers_list)
          else:
            log ("Sending nodes for get_peers.\n")
            rpc.send_closest_nodes(self.router, self.id, source_ip, source_port, tid, tid_len, info_hash)

      elif msg_type == "ANNOUNCE_PEER":
        log ("Announce peer!\n")
        self.router.add_contact(sender_id, source_ip, source_port, 1) # 1 for msg 
        if util.string_to_long(info_hash) == 0:
          log ("Got announce_peer with no info_hash\n")
          rpc.send_error(source_ip, source_port, tid, tid_len, 203, "Announce_peer with no infohash.")   
        if port == 0:
          log ("Got announce_peer with port 0\n")
          rpc.send_error(source_ip, source_port, tid, tid_len, 203, "Announce_peer with forbidden port number.")   
        if not util.token_match(token, source_ip, self.secret_package[0], self.secret_package[1]):
          log ("Got announce_peer with invalid token\n")
          rpc.send_error(source_ip, source_port, tid, tid_len, 203, "Announce_peer with invalid token.") 

        self.storage.store(sender_id, source_ip, source_port)
        log ("Sending peer announced.\n")
        rpc.peer_announced(self.id, source_ip, source_port, tid, tid_len)

  def periodic(self, callback):
    log ("do periodic stuff.\n")
    # if now > rotate_secret_time 
    if getruntime() >= self.secret_package[2]: 
      util.rotate_secret(self.secret_package[1])

    if getruntime() >= self.router.expire_stuff_time:
      self.router.expire_buckets()
      self.storage.expire_storage()
      self.lookups.expire_lookups()

    if 0 < self.lookups.lookup_time <= getruntime():
      lks = self.lookups.get_lookups()
      # execute the lookups 
      if len(lks) > 0:
        for l in lks:
          if not l.done and l.step_time <= getruntime() - 5:
            self.lookups.lookup_step(l, callback)

      # increase lookup_time for next rounds of steps 
      self.lookups.lookup_time = 0 
      for l in lks:
        if not l.done:
          l_time = l.step_time + 15 + random.random_int_below(10)    # next lookup in 15 - 25 seconds 
          if self.lookups.lookup_time == 0 or self.lookups.lookup_time > l_time:
            self.lookups.lookup_time = l_time
            # log ("L time...%.2f\n" % self.lookups.lookup_time)

    log ("Run time...%.2f\n" % getruntime())

    if self.refresh_buckets_time <= getruntime():
      refreshed = self.router.refresh_buckets()
      if refreshed:
        self.refresh_buckets_time = getruntime() + 5 + random.random_int_below(20)   # next refresh in < 25 seconds 
      else:
        self.refresh_buckets_time = getruntime() + 60 + random.random_int_below(120)   # next refresh in 1 - 3 min 

    if self.refresh_buckets_time > getruntime():
      self.to_sleep = self.refresh_buckets_time
    else:
      self.to_sleep = getruntime()
    log ("Refresh time...%.2f\n" % self.refresh_buckets_time)

    if self.lookups.lookup_time > 0 and self.lookups.lookup_time < self.to_sleep:
      if self.lookups.lookup_time > getruntime():
        self.to_sleep = self.lookups.lookup_time
      else:
        self.to_sleep = getruntime() 
    log ("Lookup time...%.2f\n" % self.lookups.lookup_time)
    log ("Sleep until...%.2f\n" % self.to_sleep)
    return True


  def ping_node(self, ip, port):
    tid = util.make_tid("pn", util.make_lid())
    return rpc.ping(self.id, ip, port, tid, len(tid))
