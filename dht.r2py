node = dy_import_module("node.r2py")
routing = dy_import_module("routing.r2py")
rpc = dy_import_module("rpc.r2py")
lookup = dy_import_module("lookup.r2py")
storage = dy_import_module("storage.r2py")
util = dy_import_module("util.r2py")
random = dy_import_module("random.r2py")


TOKEN_SIZE = 16 
K_SIZE = 8 
DHT_EVENT_VALUES = 3

class DHT:

  def __init__(self, dht_id, version_id):
    self.id = dht_id
    self.long_id = util.string_to_long(self.id)
    self.version_id = version_id 

    self.router = routing.RoutingTable(self.id, K_SIZE, version_id) 
    self.lookups = lookup.DHTLookup(self.id, self.router)
    self.storage = storage.Storage(self.id) 
    self.secret_package = util.rotate_secret() 
    self.refresh_buckets_time = getruntime() + random.random_int_below(3)
    self.to_sleep = getruntime() + 5 + random.random_int_below(10)  # first periodic call in 5 - 15 sec

    # bucket_grow_time for mybucket maintenance? 
    # token_bucket_time for rate control?

  def new_message(self, buf, source_ip, source_port, callback=None):

    if buf and len(buf) > 0:
      if util.invalid_address(source_ip, source_port):
        return self.periodic(callback)

      msg = util.parse_message(buf)
      # log (msg, "\n")
      # if msg is a string, it's an unknown query 
      if isinstance(msg, str):
        msg = util.decoder(msg)
        if msg.has_key("t"):
          rpc.send_error(source_ip, source_port, msg["t"], len(msg["t"]), 201, "Unknown query", self.version_id) 
        log ("Unknown query\n")
        return self.periodic(callback)
      # if put/get req 
      elif isinstance(msg, dict):
        if msg.has_key("q") and msg["q"] == "put":
          log ("Put!\n")
          verified = self.verify_put(msg, source_ip, source_port)
          if verified:
            sender_id = msg["a"]["id"]
            self.storage.store_value(sender_id, msg)
            # log (self.storage.retrieve_value(sender_id), "\n")
            return rpc.send_put(self.id, source_ip, source_port, msg["t"])

        elif msg.has_key("q") and msg["q"] == "get":            
          log ("Get!\n")
          self.router.add_contact(sender_id, source_ip, source_port, 1) # 1 for msg 
          verified = self.verify_get(msg, source_ip, source_port)
          if verified:
            target = msg["a"]["target"]
            target_id_long = util.string_to_long(target)
            tid = msg["t"]
            value_obj = self.storage.retrieve_value(target)
            nodes_str = "".join(self.router.get_closest_good_nodes(target_id_long))
            token = util.make_token(source_ip, self.secret_package[1])

            log ("Sending response to get.\n")
            return rpc.send_get(self.id, source_ip, source_port, value_obj, nodes_str, tid, token)
           
        else: 
          log ("Unknown query: %s\n" % msg["q"])
          return rpc.send_error(source_ip, source_port, msg["t"], len(msg["q"]), 201, "Unknown query", self.version_id) 

      # msg is not get/put 
      else:
        (msg_type, tid, tid_len, sender_id, info_hash, target, port, token, token_len,
        nodes, nodes_len, values, values_len) = msg 

        nodes_len = int(nodes_len)
        values_len = int(values_len)
        token_len= int(token_len)

        if msg_type == "ERROR" or util.string_to_long(sender_id) == 0:
          log ("Faulty message - unparseable: \n", buf, "\n")
          return self.periodic(callback)

        if sender_id == self.id and source_ip == getmyip():
          log ("Received message from self. weird.\n")
          return self.periodic(callback)

        if msg_type == "REPLY":
          if not tid_len == len(tid):
            log ("Broken tid: ", tid, "\n")
            return self.periodic(callback)

          if util.tid_match(tid, "pn"):
            log ("Pong!\n")
            self.router.add_contact(sender_id, source_ip, source_port, 0) # 0 for reply

          elif util.tid_match(tid, "gp") or util.tid_match(tid, "fn"):
            lids = (util.tid_match(tid, "gp") , util.tid_match(tid, "fn"))

            # try to find among existing lookups by searching lid 
            for lid in lids:
              if lid:
                lookup = self.lookups.find_lookup_by_tid(lid) 
                old_closest_node = lookup.get_nodes()[0]

                if lookup.lookup_done: 
                  break 
                log ("Got %d nodes for tid: %s\n" % (nodes_len/26, tid))
                # check nodes_len is normal 
                if not nodes_len % 26 == 0:
                  log ("Unexpected length for node info!\n")
                elif lid == lids[0] and lookup == None:
                  log ("Unknown lookup!\n")
                  self.router.add_contact(sender_id, source_ip, source_port, 1) # 1 for query (msg)
                else: # nodes_len normal & existing lookup - it's a proper reply 
                  self.router.add_contact(sender_id, source_ip, source_port, 0) # 0 for reply 
                  i = 0 
                  while i <= nodes_len - 26:
                    n = nodes[i:i+26]
                    # convert id, ip and port to host order and readable format 
                    n_id = ""
                    for x in n[:20]:
                      n_id += chr(int(x))

                    ip_strs = list()
                    for x in n[20:24]:
                      ip_strs.append(str(x))
                    n_ip = ".".join(ip_strs)

                    n_port = util.bytes_to_int(n[24:])  # convert port bytes back to an integer
                    i += 26 
                    # log (n_ip, ": ", n_port, "\n")
                    if n_id == self.id:
                      continue;
                    self.router.add_contact(n_id, n_ip, n_port, 2) # 2 for arbitrary msgs 

                    # insert into the corresponding lookup  
                    if lookup: 
                      lookup.insert(n_id, n_ip, n_port, 0, token, token_len)

                  if lookup: 
                    # 1 means this node has replied 
                    lookup.insert(sender_id, source_ip, source_port, 1, token, token_len)
                    # if we failed to get a new closest node, increment stable_results
                    if old_closest_node == lookup.get_nodes()[0]: 
                      self.lookups.stable_results += 1 
                    else:
                      self.lookups.stable_results = 0  

                    # log ("--------- LOOKUP ---------\n", str(lookup), "stable results: %d\n" % self.lookups.stable_results)
              
                    # avoid too frequent lookup steps 
                    sleep(0.1)
                    # if we haven't seen a new closest node for alpha(3) times 
                    if self.lookups.stable_results >= 3:
                      # query ALL lookup nodes that haven't replied 
                      self.lookups.lookup_step(lookup, callback, self.version_id, alpha=14)
                    else:
                      # query another alpha nodes that haven't replied 
                      self.lookups.lookup_step(lookup, callback, self.version_id)
                break 

            if values_len > 0 and lids[0]:
              # log ("Got %d values!\n" % (values_len/6))
              lookup = self.lookups.find_lookup_by_tid(lids[0]) 
              filtered_values = list()
              i = 0 
              while i < values_len:
                v = values[i:i+6]
                ip_strs = list()
                for x in v[0:4]:
                  ip_strs.append(str(x))
                v_ip = ".".join(ip_strs)

                v_port = util.bytes_to_int(v[4:])  # convert port bytes back to an integer
                i += 6
                filtered_values.append((v_ip, v_port))
                # log (v_ip, ": ", v_port, "\n")

              # since we've got values, stop the lookup and return callback 
              if callback and not lookup.done:
                return self.lookups.lookup_finished(lookup, callback, values=filtered_values)

          elif util.tid_match(tid, "gt"):
            res = util.decoder(buf)
            log (res, "\n")
            try: 
              tid = res["t"]
              token = res["r"]["token"]
              target_id = res["r"]["id"]
              nodes = res["r"]["nodes"]
              values = res["r"]["v"]
              sig = ""
              if res["a"].has_key("sig"):
                sig = res["a"]["sig"]
                # verify signature, if invalid, return error 206 invalid sig

              lid = util.tid_match(tid, "gt")
              lookup = self.lookups.find_lookup_by_tid(lid) 
              old_closest_node = lookup.get_nodes()[0]

              # check nodes_len is normal 
              if not len(nodes) % 26 == 0:
                log ("Unexpected length for node info!\n")
              elif lookup == None:
                log ("Unknown get lookup!\n")
                self.router.add_contact(sender_id, source_ip, source_port, 1)   # 1 for query (msg)
              else: # nodes_len normal & existing lookup - it's a proper reply 
                if not lookup.lookup_done:
                  # return if we've got value item 
                  if len(values) > 0:
                    v = util.decoder(values)
                    return self.lookups.lookup_finished(lookup, callback, values=v)

                  log ("Got %d nodes for tid: %s\n" % (len(nodes)/26, tid))
                  self.router.add_contact(sender_id, source_ip, source_port, 0)   # 0 for reply   
                  i = 0 
                  while i <= len(nodes) - 26:
                    n = nodes[i:i+26]
                    # convert id, ip and port to host order and readable format 
                    n_id = ""
                    for x in n[:20]:
                      n_id += chr(int(x))

                    ip_strs = list()
                    for x in n[20:24]:
                      ip_strs.append(str(x))
                    n_ip = ".".join(ip_strs)

                    n_port = util.bytes_to_int(n[24:])  # convert port bytes back to an integer
                    i += 26 
                    # log (n_ip, ": ", n_port, "\n")
                    if n_id == self.id:
                      continue;
                    self.router.add_contact(n_id, n_ip, n_port, 2) # 2 for arbitrary msgs 

                    # insert into the corresponding lookup  
                    if lookup: 
                      lookup.insert(n_id, n_ip, n_port, 0, token, len(token))

                  if lookup: 
                    # 1 means this node has replied 
                    lookup.insert(sender_id, source_ip, source_port, 1, token, len(token))
                    # if we failed to get a new closest node, increment stable_results
                    if old_closest_node == lookup.get_nodes()[0]: 
                      self.lookups.stable_results += 1 
                    else:
                      self.lookups.stable_results = 0                
                    # avoid too frequent lookup steps 
                    sleep(0.1)
                    # if we haven't seen a new closest node for alpha(3) times 
                    if self.lookups.stable_results >= 3:
                      # query ALL lookup nodes that haven't replied 
                      self.lookups.lookup_step(lookup, callback, self.version_id, alpha=14)
                    else:
                      # query another alpha nodes that haven't replied 
                      self.lookups.lookup_step(lookup, callback, self.version_id)
              
            except:
              log ("Faulty response to get.\n")                

          elif util.tid_match(tid, "ap") or util.tid_match(tid, "pt"):  
            lids = (util.tid_match(tid, "ap"), util.tid_match(tid, "pt"))
            for lid in lids:
              if lid: 
                lookup = self.lookups.find_lookup_by_tid(lid) 
                if lookup == None:
                  log ("Unknown announce_peer/put lookup!\n")
                  self.router.add_contact(sender_id, source_ip, source_port, 1)   # 1 for query (msg)
                else:
                  self.router.add_contact(sender_id, source_ip, source_port, 0)   # 0 for reply 
                  acked = 0 
                  for n in lookup.get_good_nodes():
                    if n.ip == source_ip and n.port == source_port:
                      # the node has acked already 
                      acked = n.acked

                      n.last_req = 0 
                      n.replied = 1 
                      n.last_replied = getruntime()
                      n.acked = 1 
                      n.pinged = 0 
                      break 

                  if not acked: 
                    log ("Got new reply to announce_peer/put from: %s %d\n" %(source_ip, source_port))
                    self.lookups.lookup_step(lookup, callback, self.version_id, finished=1)
                break 

          else:
            log ("Unexpected reply: \n%s (%d)\n" % (buf, len(buf)))
            log (msg, "\n")

        elif msg_type == "PING":
          log ("Ping!\n")
          self.router.add_contact(sender_id, source_ip, source_port, 1) # 1 for msg 
          log ("Sending pong.\n")
          return rpc.pong(self.id, source_ip, source_port, tid, tid_len, self.version_id)

        elif msg_type == "FIND_NODE":
          log ("Find node!\n")
          self.router.add_contact(sender_id, source_ip, source_port, 1) # 1 for msg 
          log ("Sending closest node to find_node req.\n")
          return rpc.send_closest_nodes(self.router, self.id, source_ip, source_port, tid, tid_len, target, self.version_id)

        elif msg_type == "GET_PEERS":
          log ("Get peers!\n")
          self.router.add_contact(sender_id, source_ip, source_port, 1) # 1 for msg 
          if util.string_to_long(info_hash) == 0:
            log ("Got get_peers with no info_hash\n")
            rpc.send_error(source_ip, source_port, tid, tid_len, 203, "Get_peers with no infohash.", self.version_id)
          else:
            peers_list = self.storage.retrieve(info_hash)
            token = util.make_token(source_ip, self.secret_package[1])
            if peers_list:
              log ("Sending found peers.\n")
              return rpc.send_closest_nodes(self.id, source_ip, source_port, tid, tid_len, info_hash, 
                                          token, TOKEN_SIZE, peers_list, self.version_id)
            else:
              log ("Sending nodes for get_peers.\n")
              return rpc.send_closest_nodes(self.router, self.id, source_ip, source_port, tid, tid_len, info_hash, self.version_id)

        elif msg_type == "ANNOUNCE_PEER":
          log ("Announce peer!\n")
          self.router.add_contact(sender_id, source_ip, source_port, 1) # 1 for msg 
          if util.string_to_long(info_hash) == 0:
            log ("Got announce_peer with no info_hash\n")
            rpc.send_error(source_ip, source_port, tid, tid_len, 203, "Announce_peer with no infohash", self.version_id)   
          if port == 0:
            log ("Got announce_peer with port 0\n")
            rpc.send_error(source_ip, source_port, tid, tid_len, 203, "Announce_peer with forbidden port number", self.version_id)   
          if not util.token_match(token, source_ip, self.secret_package[0], self.secret_package[1]):
            log ("Got announce_peer with invalid token\n")
            rpc.send_error(source_ip, source_port, tid, tid_len, 203, "Announce_peer with invalid token", self.version_id) 

          self.storage.store(sender_id, source_ip, source_port)
          log ("Sending peer announced.\n")
          return rpc.peer_announced(self.id, source_ip, source_port, tid, tid_len, self.version_id)



  def verify_put(self, msg, source_ip, source_port):
    try: 
      value = msg["a"]["v"]
      opts = msg["a"]
      tid = msg["t"]
      token = msg["a"]["token"]
      sender_id = msg["a"]["id"]
      st = self.storage.retrieve_value(sender_id)

      if len(util.encoder(value)) >= 1000:
        rpc.send_error(source_ip, source_port, tid, len(tid), 205, "Message too big", self.version_id)
        return False 
      if not util.token_match(token, source_ip, self.secret_package[0], self.secret_package[1]):
        rpc.send_error(source_ip, source_port, tid, len(tid), 203, "Invalid token", self.version_id)
        return False 
      if opts.has_key("salt") and len(opts["salt"]) > 64:
        rpc.send_error(source_ip, source_port, tid, len(tid), 207, "Salt too big", self.version_id)
        return False 
      if st:
        if opts.has_key("cas") and not opts["cas"] == st["seq"]:
          rpc.send_error(source_ip, source_port, tid, len(tid), 301, "CAS mismatch. Re-read and try again", self.version_id)
          return False 
        if opts["seq"] <= st["seq"]:
          rpc.send_error(source_ip, source_port, tid, len(tid), 302, "Sequence number less than current", self.version_id)
          return False 
      # TODO: verify signiture - need ed25519 supercop/ref10 support 
  
    except:
      log ("Invalid put request!\n")
      if msg.has_key("t"):
        rpc.send_error(source_ip, source_port, msg["t"], len(msg["t"]), 203, "Invalid arguments", self.version_id) 
      return False 

    return True 

  def verify_get(self, msg, source_ip, source_port):
    target = msg["a"].get("target")
    tid = msg.get("t")
    if not tid: 
      return False 
    if not target:
      log ("Got get request with no target\n")
      rpc.send_error(source_ip, source_port, tid, len(tid), 203, "Get with no target.", self.version_id)
      return False 
    return True 


  def periodic(self, callback):
    log ("do periodic stuff.\n")
    # if now > rotate_secret_time 
    if getruntime() >= self.secret_package[2]: 
      util.rotate_secret(self.secret_package[1])

    if getruntime() >= self.router.expire_stuff_time:
      self.router.expire_buckets()
      self.storage.expire_storage()
      self.lookups.expire_lookups()

    if 0 < self.lookups.lookup_time <= getruntime():
      lks = self.lookups.get_lookups()
      # execute the lookups 
      if len(lks) > 0:
        for l in lks:
          if not l.done and l.step_time <= getruntime() - 5:
            if l.lookup_done: 
              self.lookups.lookup_step(l, callback, self.version_id, finished=1)
            else:
              self.lookups.lookup_step(l, callback, self.version_id)

      # increase lookup_time for next rounds of steps 
      self.lookups.lookup_time = 0 
      for l in lks:
        if not l.done:
          l_time = l.step_time + 5 + random.random_int_below(5)    # next lookup in 5 - 10 seconds 
          if self.lookups.lookup_time == 0 or self.lookups.lookup_time > l_time:
            self.lookups.lookup_time = l_time
            # log ("L time...%.2f\n" % self.lookups.lookup_time)

    log ("Run time...%.2f\n" % getruntime())

    if self.refresh_buckets_time <= getruntime():
      refreshed = self.router.refresh_buckets()
      if refreshed:
        self.refresh_buckets_time = getruntime() + 5 + random.random_int_below(20)   # next refresh in < 25 seconds 
      else:
        self.refresh_buckets_time = getruntime() + 60 + random.random_int_below(120)   # next refresh in 1 - 3 min 

    if self.refresh_buckets_time > getruntime():
      self.to_sleep = self.refresh_buckets_time
    else:
      self.to_sleep = getruntime()
    log ("Refresh time...%.2f\n" % self.refresh_buckets_time)

    if self.lookups.lookup_time > 0 and self.lookups.lookup_time < self.to_sleep:
      if self.lookups.lookup_time > getruntime():
        self.to_sleep = self.lookups.lookup_time
      else:
        self.to_sleep = getruntime() 
    log ("Lookup time...%.2f\n" % self.lookups.lookup_time)
    log ("Sleep until...%.2f\n" % self.to_sleep)
    return True


  def ping_node(self, ip, port):
    tid = util.make_tid("pn", util.make_lid())
    return rpc.ping(self.id, ip, port, tid, len(tid), self.version_id)
