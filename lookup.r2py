util = dy_import_module("util.r2py")
rpc = dy_import_module("rpc.r2py")


DHT_LOOKUP_EXPIRE_TIME = 62 * 60 
LOOKUP_CAPACITY = 14

DHT_EVENT_SETUP_DONE = 0 
DHT_EVENT_LOOKUP_DONE = 1
DHT_EVENT_ANNOUNCE_DONE = 2 
DHT_EVENT_VALUES = 3
DHT_EVENT_GET_DONE = 4 
DHT_EVENT_PUT_DONE = 5
DHT_EVENT_VALUE_ITEM = 6 

class DHTLookup:

  def __init__(self, string_id, routing_table):
    self.id = string_id 
    self.lookups = list()
    self.lookup_id = util.make_lid()
    self.lookup_time = 0 
    self.router = routing_table
    self.stable_results = 0 


  """
    port number implications:

    - 0 for pure lookup (GET_PEER)
    - 1 for GET 
    - 2 for PUT 
    - > 2 for ANNOUNCE_PEER  
  
  """
  def dht_lookup(self, string_id, port, callback, version, value=None, opts=None):
    # refresh 
    self.stable_results = 0 
    new_lookup = True 
    target_id = util.string_to_long(string_id)

    # reusing data from an old lookup  
    for l in self.lookups:
      if target_id == l.target_id:
        l.done = 0 
        new_lookup = False 
        for n in l.get_nodes():
          # discard dubious node 
          if n.pinged >= 3 or n.last_replied < getruntime() - 120 * 60:
            l.remove(n)
        # get some new lookup nodes 
        l = self.router.get_lookup_nodes(l, target_id)
        l.port = port 
        l.value = value 
        l.opts = opts 
        # self.lookup_step(l, callback, version)
        for n in l.get_good_nodes():
          self.lookup_get_peers(l, version, n)
        break 

    if new_lookup:
      self.lookup_id += 1 
      newest = Lookup(string_id, self.lookup_id, LOOKUP_CAPACITY, port, value, opts)
      oldest = None 
      # find the oldest lookup
      for l in self.lookups:
        if l.done and (oldest == None or l.step_time < oldest.step_time):
          oldest = l 
      # if the oldest has expired, replace it with the new lookup, otherwise append the new lookup 
      if oldest and oldest.step_time < getruntime() - DHT_LOOKUP_EXPIRE_TIME:
        index = self.lookups.index(oldest) 
        self.lookups[index] = newest
      else:
        self.lookups.append(newest)

      newest = self.router.get_lookup_nodes(newest, target_id)
      # newest.port = port 
      # log ("new ")
      self.lookup_step(newest, callback, version)
      # log (newest.get_all_ids(), "\n")
    # update lookup_time 
    self.lookup_time = getruntime()

  def lookup_step(self, lookup, callback, version, alpha=3, finished=0):
    # log ("ALPHA: ", alpha, "\n")
    # see if we have got reply from k (8) live nodes 
    all_replied = lookup.all_replied()
    # if we have k live nodes or as many as we can get 
    if all_replied or finished:
      lookup.lookup_done = 1 
      # finished for pure lookup 
      log ("Lookup Port: %d\n" % lookup.port)
      # if lookup is for get_peer or get 
      if lookup.port < 2:
        self.lookup_finished(lookup, callback)
      else: 
        all_acked = 0  
        count = 0 
        for n in lookup.get_good_nodes():
          if n.acked:
            all_acked += 1 
          elif not n.acked and n.token:
            # if lookup is for announce_peer 
            if lookup.port > 2:
              log ("Sending announce peer to: %s %d\n" %(n.ip, n.port))
              tid = util.make_tid("ap", lookup.tid)
              rpc.announce_peer(self.id, n.ip, n.port, tid, len(tid), lookup.id, lookup.port, n.token, n.token_len, version)
            else: # lookup is for put 
              log ("Sending put to: %s %d\n" %(n.ip, n.port))
              tid = util.make_tid("pt", lookup.tid)
              rpc.put(self.id, lookup.value, n.ip, n.port, tid, n.token, lookup.opts)

            n.pinged += 1 
            n.last_req = getruntime()
            # find node with this id in routing table 
            router_node = self.router.find_node(n.long_id)
            if router_node:
              self.router.pinged(router_node)

        if all_acked >= 8:
          log ("All acked - thus finished! \n")
          self.lookup_finished(lookup, callback) 
      lookup.step_time = getruntime()
      return 

    # if not all replied 
    # ignore too frequent lookups 
    if lookup.step_time > getruntime() - 0.1:
      log ("TOO FREQUENT\n")
      return 

    # send alpha get_peers / get requests to nodes we have NOT queried 
    send_count = 0       
    if lookup.port == 1 or lookup.port == 2:
        for n in lookup.get_nodes():
          if n.pinged < 3 and not n.replied and n.last_req < getruntime() - 5:
            send_count += self.lookup_get(lookup, n)
          if send_count >= alpha:
            break
    else:
      for n in lookup.get_nodes():
          if n.pinged < 3 and not n.replied and n.last_req < getruntime() - 5:
            send_count += self.lookup_get_peers(lookup, version, n)
          if send_count >= alpha:
            break

    lookup.step_time = getruntime()

  def lookup_finished(self, lookup, callback, values=None):
    lookup.done = 1 
    lookup.step_time = getruntime()
    if callback:
      event = -1 
      if values:
        if lookup.port == 1:
          return callback(DHT_EVENT_VALUE_ITEM, lookup.id, values)
        else:
          return callback(DHT_EVENT_VALUES, lookup.id, values, len(values))
      elif lookup.port > 2:
        event = DHT_EVENT_ANNOUNCE_DONE
      elif lookup.port == 2:
        event = DHT_EVENT_PUT_DONE
      elif lookup.port == 1:
        event = DHT_EVENT_GET_DONE
      else:
        if lookup.id == self.id:
          event = DHT_EVENT_SETUP_DONE
        else:
          event = DHT_EVENT_LOOKUP_DONE

      return callback(event, lookup.id, lookup.get_good_nodes(), len(lookup.get_good_nodes()))  


  def lookup_get_peers(self, lookup, version, node):
    if not node or node.pinged >= 3 or node.last_req > getruntime() - 5:
      return 0 
    log ("Sending get_peers.\n")
    tid = util.make_tid("gp", lookup.tid)
    # send get_peers 
    rpc.get_peers(self.id, node.ip, node.port, tid, len(tid), lookup.id, version)
    node.pinged += 1 
    node.last_req = getruntime()
    router_node = self.router.find_node(node.long_id)
    if router_node:
      self.router.pinged(router_node)
    return 1 

  def lookup_get(self, lookup, node):
    if not node or node.pinged >= 3 or node.last_req > getruntime() - 5:
        return 0 
    log ("Sending get.\n")
    tid = util.make_tid("gt", lookup.tid)
    rpc.get(self.id, lookup.id, node.ip, node.port, tid)
    node.pinged += 1 
    node.last_req = getruntime()
    router_node = self.router.find_node(node.long_id)
    if router_node:
      self.router.pinged(router_node)
    return 1 

  def find_lookup_by_tid(self, tid):
    for l in self.lookups:
      if l.tid == util.string_to_long(tid):
        return l 
    return None 

  def expire_lookups(self):
    for l in self.lookups:
      if l.step_time < getruntime() - DHT_LOOKUP_EXPIRE_TIME:
        self.lookups.remove(l)

  def get_lookups(self):
    return self.lookups 

class Lookup:

  def __init__(self, string_id, tid, capacity, port=0, value=None, opts=None):
    self.id = string_id
    self.target_id = util.string_to_long(self.id)
    self.capacity = capacity
    self.tid = tid 
    self.port = port  # 0 for pure searches 
    self.step_time = 0 
    self.done = 0 
    self.lookup_done = 0 
    self.value = value 
    self.opts = opts 
    self.list = list() # sorted: closest at head, furthest at tail 

  # Insert into the lookup list: 
  # if new contact's dist to target is less than the furthest in the list, 
  # insert it and discard the old furthest if necessary (exceed capacity). 
  # Otherwise, if the contact already exist or is further than the furthest, discard it. 
  def insert(self, id, ip, port, replied=0, token=None, token_len=0):

    lookup_node = Lookup_Node(id, ip, port, replied, token, token_len)

    if id == self.id:
      return 

    if len(self.list) == 0:
      self.list.append(lookup_node)
      return 

    for i in range(len(self.list)):
      n = self.list[i]
      comparison = util.compare_distance(self.target_id, lookup_node.long_id, n.long_id)
      if comparison == 0:
        # found 
        if replied:
          n.replied = 1 
          n.last_replied = getruntime()
          n.last_req = 0 
          n.pinged = 0 

          if token:
            if token_len >= 40:
              log ("Overlong token.\n")
            else:
              n.token = token 
              n.token_len = token_len 
        return 
      elif comparison > 0:
        continue 
      else: # node is closer  
        self.list.insert(i, lookup_node)
        if len(self.list) > self.capacity:
          # just pop the last (furthest) node, whether it has replied or not 
          self.list.pop()
        return 
    # if there's room in capacity after looping through self.list, just append new node 
    if len(self.list) < self.capacity:
      self.list.append(lookup_node)

  def remove(self, lookup_node):
    if lookup_node in self.list:
      self.list.remove(lookup_node)
      return True 
    return False 

  # we only need at least k (8) replied nodes to count as all_replied  
  def all_replied(self):
    live_node_count = 0 

    for n in self.list:
      if n.pinged >= 3: 
        continue 
      if not n.replied:
        continue     
      live_node_count += 1 

    if live_node_count >= 8:
        return True 
    return False 

  def get_nodes(self):
    return self.list 

  def get_all_ids(self):
    return [n.id for n in self.list]

  def is_full(self):
    return len(self.list) >= self.capacity

  def __str__(self):
    output = ("target_id: %s\ntid: %s, port: %d\nstep_time: %.2f, done: %d\n" % 
              (self.target_id, self.tid, self.port, self.step_time, self.done))
    output += "lookup nodes (%d): \n" % len(self.list)
    for l in self.list:
      output += l.ip + "\t" + str(l.replied) + "\n"
    return output 

  def print_good_nodes(self):
    output = ("target_id: %s\ntid: %s, port: %d\nstep_time: %.2f, done: %d\n" % 
            (self.target_id, self.tid, self.port, self.step_time, self.done))
    output += "good lookup nodes: \n"
    for l in self.list:
      if l.replied:
        output += l.ip + "\t" + str(l.replied) + "\n"
    return output 

  def get_good_nodes(self):
    l_list = list()
    for l in self.list:
      if l.replied:
        l_list.append(l)
    return l_list 

class Lookup_Node():
  def __init__(self, id, ip, port, replied, token, token_len):
    self.id = id 
    self.long_id = util.string_to_long(self.id)
    self.ip = ip 
    self.port = port 
    self.replied = replied 
    self.last_replied = 0 
    self.last_req = 0 
    self.acked = 0 
    self.token = token 
    self.token_len = token_len
    self.pinged = 0 
