util = dy_import_module("util.r2py")
rpc = dy_import_module("rpc.r2py")
dy_import_module_symbols("constants.py")

DHT_LOOKUP_EXPIRE_TIME = 62 * 60 
LOOKUP_CAPACITY = 14

class DHTLookup:

  def __init__(self, string_id, routing_table):
    self.id = string_id 
    self.lookups = list()
    self.lookup_id = util.make_lid()
    self.lookup_time = 0 
    self.router = routing_table
    self.stable_results = 0 


  """
    port number implications:
    
    - 0 for pure lookup (GET_PEER)
    - 1 for GET 
    - 2 for PUT 
    - > 2 for ANNOUNCE_PEER  
  
  """
  def dht_lookup(self, string_id, port, callback, version, my_port=63101, value=None, opts=None):
    self.stable_results = 0 
    target_id = util.bytes_to_int(string_id)

    self.lookup_id += 1 
    newest = Lookup(string_id, self.lookup_id, LOOKUP_CAPACITY, port, value, opts)
    oldest = None 
    # find the oldest lookup
    for l in self.lookups:
      if l.done and (oldest == None or l.step_time < oldest.step_time):
        oldest = l 
    # if the oldest has expired, replace it with the new lookup, otherwise append the new lookup 
    if oldest and oldest.step_time < getruntime() - DHT_LOOKUP_EXPIRE_TIME:
      index = self.lookups.index(oldest) 
      self.lookups[index] = newest
    else:
      self.lookups.append(newest)

    newest = self.router.get_lookup_nodes(newest, target_id)
    # log (newest)
    self.lookup_step(newest, callback, version, my_port)
    # update lookup_time 
    self.lookup_time = getruntime()

  def lookup_step(self, lookup, callback, version, my_port=63101, alpha=3, finished=0):

    if lookup.done:
      return self.lookup_finished(lookup, callback)

    # see if we have got reply from k (8) live nodes 
    all_replied = lookup.all_replied()
    # if we have k live nodes or as many as we can get 
    if all_replied or finished:
      lookup.lookup_done = 1 
      # log ("Lookup Port: %d\n" % lookup.port)
      # if lookup is for get_peer or get, we're finished 
      if lookup.port < 2:
        self.lookup_finished(lookup, callback)
      else: 
        all_acked = 0  
        count = 0 
        for n in lookup.get_good_nodes():
          if n.acked:
            all_acked += 1 
          elif not n.acked and n.token:
            # if lookup is for announce_peer 
            if lookup.port > 2:
              # log ("Sending announce peer to: %s %d\n" %(n.ip, n.port))
              tid = util.make_tid("ap", lookup.tid)
              rpc.announce_peer(self.id, n.ip, n.port, tid, len(tid), lookup.id, lookup.port, n.token, n.token_len, my_port, version)
            else: # lookup is for put 
              log ("Sending put to: %s %d\n" %(n.ip, n.port))
              tid = util.make_tid("pt", lookup.tid)
              rpc.put(lookup.id, lookup.value, n.ip, n.port, tid, n.token, my_port, lookup.opts)

            n.pinged += 1 
            n.last_req = getruntime()
            # find node with this id in routing table 
            router_node = self.router.find_node(n.long_id)
            if router_node:
              self.router.pinged(router_node)
        log ("all_acked num: %d \n" % all_acked)
        if all_acked >= 8:
          log ("All acked - thus finished! \n")
          self.lookup_finished(lookup, callback) 

      lookup.step_time = getruntime()
      return 
    else:
      # if not all replied 
      # send alpha get_peers / get requests to nodes we have NOT queried 
      send_count = 0       
      if lookup.port == 1 or lookup.port == 2:
        for n in lookup.get_nodes():
          if n.pinged < 3 and n.replied == 0 and n.last_req < getruntime() - 1:
            log ("Sending get to %s: %d\n" %(n.ip, n.port))
            send_count += self.lookup_get(lookup, n, my_port)
          if send_count >= alpha:
            break
      else:
        for n in lookup.get_nodes():
          if n.pinged < 3 and n.replied == 0 and n.last_req < getruntime() - 1:
            log ("Sending get_peers to %s: %d\n" %(n.ip, n.port))
            send_count += self.lookup_get_peers(lookup, version, n, my_port)
          if send_count >= alpha:
            break

      lookup.step_time = getruntime()

  def lookup_finished(self, lookup, callback, values=None, res=None):
    lookup.done = 1 
    lookup.step_time = getruntime()
    # self.lookups.remove(lookup)

    if callback:

      event = DHT_EVENT_ERROR
      if values:
        # # we do not want to find values during setup
        if lookup.port == 0 and lookup.id == self.id:
          lookup.done = 0 
          return 
        if lookup.port == 1:
          return callback(DHT_EVENT_VALUE_ITEM, lookup.id, values, 0, res)
        else:
          return callback(DHT_EVENT_VALUES, lookup.id, values, len(values))
      elif lookup.port > 2:
        acked_nodes = [n for n in lookup.get_good_nodes() if n.acked]
        return callback(DHT_EVENT_ANNOUNCE_DONE, lookup.id, acked_nodes, len(acked_nodes))  
      elif lookup.port == 2:
        acked_nodes = [n for n in lookup.get_good_nodes() if n.acked]
        return callback(DHT_EVENT_PUT_DONE, lookup.id, acked_nodes, len(acked_nodes)) 
      elif lookup.port == 1:
        event = DHT_EVENT_GET_DONE
      elif lookup.port == 0:
        if lookup.id == self.id:
          event = DHT_EVENT_SETUP_DONE
        else:
          event = DHT_EVENT_LOOKUP_DONE

      return callback(event, lookup.id, lookup.get_good_nodes(), len(lookup.get_good_nodes()))  
    else:
      raise Exception("Must provide a callback for DHT operations.")

  def lookup_get_peers(self, lookup, version, node, my_port):
    if lookup.done:
      return 0 
    if not node or node.pinged >= 3 or node.last_req > getruntime() - 1:
      return 0 
    # log ("Sending get_peers to %s %d\n" %(node.ip, node.port))
    tid = util.make_tid("gp", lookup.tid)
    # send get_peers 
    rpc.get_peers(self.id, node.ip, node.port, tid, len(tid), lookup.id, my_port, version)
    node.pinged += 1 
    node.last_req = getruntime()
    router_node = self.router.find_node(node.long_id)
    if router_node:
      self.router.pinged(router_node)
    return 1 

  def lookup_get(self, lookup, node, my_port):
    if lookup.done:
      return 0 
    if not node or node.pinged >= 3 or node.last_req > getruntime() - 1:
      return 0 
    tid = util.make_tid("gt", lookup.tid)
    rpc.get(self.id, lookup.id, node.ip, node.port, tid, my_port)
    node.pinged += 1 
    node.last_req = getruntime()
    router_node = self.router.find_node(node.long_id)
    if router_node:
      self.router.pinged(router_node)
    return 1 

  def find_lookup_by_tid(self, tid):
    for l in self.lookups:
      if l.tid == util.bytes_to_int(tid):
        return l 
    return None 

  def expire_lookups(self):
    for l in self.lookups:
      if l.step_time < getruntime() - DHT_LOOKUP_EXPIRE_TIME:
        self.lookups.remove(l)

  def get_lookups(self):
    return self.lookups 

class Lookup:

  def __init__(self, string_id, tid, capacity, port=0, value=None, opts=None):
    self.id = string_id
    self.target_id = util.bytes_to_int(self.id)
    self.capacity = capacity
    self.tid = tid 
    self.port = port  # 0 for pure searches 
    self.step_time = 0 
    self.done = 0 
    self.lookup_done = 0 
    self.value = value 
    self.opts = opts 
    self.list = list() # sorted: closest at head, furthest at tail 

  # Insert into the lookup list: 
  # if new contact's dist to target is less than the furthest in the list, 
  # insert it and discard the old furthest if necessary (exceed capacity). 
  # Otherwise, if the contact already exist or is further than the furthest, discard it. 
  def insert(self, id, ip, port, replied=0, token=None, token_len=0):

    lookup_node = Lookup_Node(id, ip, port, replied, token, token_len)

    # if node id is the same as our own, return 
    if id == self.id:
      return 

    if len(self.list) == 0:
      self.list.append(lookup_node)
      return 

    for i in range(len(self.list)):
      n = self.list[i]
      comparison = util.compare_distance(self.target_id, lookup_node.long_id, n.long_id)
      if comparison == 0:
        # found 
        # log ("found! %d at index %d \n" % (port, i))
        if replied:
          n.replied = 1 
          n.last_replied = getruntime()
          n.last_req = 0 
          n.pinged = 0 

          if token:
            if token_len >= 40:
              log ("Overlong token.\n")
            else:
              n.token = token 
              n.token_len = token_len 
        return 
      elif comparison > 0:
        continue 
      else: # node is closer  
        self.list.insert(i, lookup_node)
        if len(self.list) > self.capacity:
          # pop the furthest node that hasn't replied 
          i = -1     
          while self.list[i].replied and i > len(self.list) * -1:
            i -= 1 
          # in case all have replied
          if i >= len(self.list) * -1:
            self.list.pop(i)
          else:
            self.list.pop()
        return 
    # if there's room in capacity after looping through self.list, just append new node 
    if len(self.list) < self.capacity:
      self.list.append(lookup_node)


  def remove(self, lookup_node):
    if lookup_node in self.list:
      self.list.remove(lookup_node)
      return True 
    return False 

  # we only need at least k (8) replied nodes to count as all_replied  
  def all_replied(self):
    live_node_count = 0 

    for n in self.list:
      if n.pinged >= 3: 
        continue 
      if not n.replied:
        continue     
      live_node_count += 1 

    if live_node_count >= 8:
        return True 
    return False 

  def get_nodes(self):
    return self.list 

  def get_all_ids(self):
    return [n.id for n in self.list]

  def is_full(self):
    return len(self.list) >= self.capacity

  def __str__(self):
    output = ("target_id: %s\ntid: %s, port: %d\nstep_time: %.2f, done: %d, lookup_done: %d\n" % 
              (self.target_id, self.tid, self.port, self.step_time, self.done, self.lookup_done))
    output += "lookup nodes (%d): \n" % len(self.list)
    for l in self.list:
      output += l.ip + ": " + str(l.port) + "\t" + str(l.replied) + "\n"
    return output 

  def print_good_nodes(self):
    output = ("target_id: %s\ntid: %s, port: %d\nstep_time: %.2f, done: %d, lookup_done: %d\n" % 
            (self.target_id, self.tid, self.port, self.step_time, self.done, self.lookup_done))
    output += "good lookup nodes: \n"
    for l in self.list:
      if l.replied:
        output += l.ip + ": " + str(l.port) + "\t" + str(l.replied) + "\n"
    log(output)

  def get_good_nodes(self):
    l_list = list()
    for l in self.list:
      if l.replied:
        l_list.append(l)
    return l_list 

class Lookup_Node():
  def __init__(self, id, ip, port, replied, token, token_len):
    self.id = id 
    self.long_id = util.bytes_to_int(self.id)
    self.ip = ip 
    self.port = port 
    self.replied = replied 
    self.last_replied = 0 
    self.last_req = 0 
    self.acked = 0 
    self.token = token 
    self.token_len = token_len
    self.pinged = 0 
  